---
sidebar_position: 12
---

import { TagDocRender } from '@site/src/components/TagDocRender';
import { AttributeType } from '@site/src/components/AttributeType.class';
import useBaseUrl from '@docusaurus/useBaseUrl';

# Selector

## Overview

Fetches one or more entities based on a [Selector-Expression](../types#selector), which is either relative to the recipient of the message (if provided when calling the API) or the explicitly provided location (that always takes precedence). The `renderer` is handed an implicit environment-variable called `selector_result` which is a list of type [PlatformEntity](../types#platformentity), as well as a `selector_origin`, which is the [Location](../types#location) which served as an origin.

<TagDocRender tag={{
  name: 'selector',
  aliases: [],
  selfClosing: true,
  attributes: [
    {
      name: 'selector',
      aliases: [],
      description: 'Selector to decide entities with',
      fallback: null,
      multiValue: false,
      type: AttributeType.SELECTOR,
    },
    {
      name: 'at',
      aliases: [],
      description: 'Explicit origin of the selector',
      fallback: 'null',
      multiValue: false,
      type: AttributeType.COORDINATES,
    },
    {
      name: 'renderer',
      aliases: [],
      description: [
        'Appearance-dictating markup; introduces:',
        '- selector_result: List<PlatformEntity>',
        '- selector_origin: PlatformEntity',
      ],
      fallback: 'null',
      multiValue: false,
      type: AttributeType.MARKUP,
    }
  ]
}} />

## Example

### Plain Appearance

When not providing a custom renderer, the default implementation will mimick the plain look and feel of the `/tellraw` command.

```!component-markup
The results are: <selector selector="@e[limit=10]"/>
```

### At Location

In order to select entities at a custom position, simply supply the desired coordinates.

```!component-markup
The results are: <selector at="59 73 112" selector="@e[limit=10]"/>
```

### Distances And Teleportation

Since there are no restrictions when it comes to the complexity of the renderer, nuanced scenarios like the following, displaying a nicely-formatted distance as well as providing a teleportation-command that's not only displayed when hovering but also executed when clicking is no challenge whatsoever. Granted, calculating the euclidean distance may look a bit convoluted, but we're taking it to the extremes here.

```!component-markup
The results are: <selector
  selector="@e[limit=10]"
  renderer={
    <hover-text
      *for-entity="selector_result"
      *for-separator={ <gray>,<space/> }
      *let-command=`/tp {entity.x} {entity.y} {entity.z}`
      value={ <gray>{command} }
    >
      <run-command [value]="command">
        <u><&b>{entity.name}</u><space/>
        <&3><number
          format=".0"
          [value]="((entity.x - selector_origin.x)^2 + (entity.y - selector_origin.y)^2 + (entity.z - selector_origin.z)^2)^(.5)"
        />
  }
/>
```