---
sidebar_position: 6
---

# Component Constructor

This project remains entirely platform-agnostic by working with externally provided implementations of
the `ComponentConstructor`, which comes with many benefits, such as the fact that no intermediate representation
and thus no conversions are necessary - also, proper automated testing can be conducted using independent
mocks.

In order to construct- and interact with components native to the platform at hand, the
component-constructor offers various endpoints, allowing the system to unfold the full
set of features with just a few basic necessities provided.

```java
/**
 * @param <B> Component(B)uilder - Useful as an intermediate if components are immutable, seeing how
 *            the construction-process inherently depends on in-place alteration; simply let
 *            {@link ComponentConstructor#finalizeComponent(Object)} be a passthrough if the
 *            components on your platform are already mutable.
 * @param <C> (C)omponent - The final, platform-specific result, not to be altered any further.
 */
public interface ComponentConstructor<B, C> {

  Class<C> getComponentClass();

  boolean doesSupport(ConstructorFeature feature);

  // ================================================================================
  // SlotContext
  // ================================================================================

  SlotContext getSlotContext(SlotType slot);

  // ================================================================================
  // TerminalNode
  // ================================================================================

  B createTextComponent(String text);

  B createKeyComponent(String key);

  B createTranslateComponent(String key, List<C> with, @Nullable String fallback);

  // ================================================================================
  // Click-Action
  // ================================================================================

  void setClickChangePageAction(B component, String value);

  void setClickCopyToClipboardAction(B component, String value);

  void setClickOpenFileAction(B component, String value);

  void setClickOpenUrlAction(B component, String value);

  void setClickRunCommandAction(B component, String value);

  void setClickSuggestCommandAction(B component, String value);

  // ================================================================================
  // Hover-Action
  // ================================================================================

  void setHoverItemAction(
    B component,
    String material,
    @Nullable Integer count,
    @Nullable C name,
    @Nullable List<C> lore,
    boolean hideProperties
  );

  void setHoverTextAction(B component, C text);

  void setHoverEntityAction(B component, String type, UUID id, @Nullable C name);

  // ================================================================================
  // Insert-Action
  // ================================================================================

  void setInsertAction(B component, String value);

  // ================================================================================
  // Styling
  // ================================================================================

  void setColor(B component, long packedColor, boolean allowOverwrite);

  void setShadowColor(B component, long packedColor);

  void setFont(B component, String font);

  void setObfuscatedFormat(B component, TriState value);

  void setBoldFormat(B component, TriState value);

  void setStrikethroughFormat(B component, TriState value);

  void setUnderlinedFormat(B component, TriState value);

  void setItalicFormat(B component, TriState value);

  // ================================================================================
  // Children
  // ================================================================================

  /**
   * Called once a component has been fully constructed and no more changes are to be
   * made. Since Adventure is deeply immutable and thereby enforces builders, this stage
   * would call the build method, as to end up with a final component to pass on.
   * @param component Component to be finalized, as created by the corresponding creation-methods.
   * @return Finalized component, ready to be used wherever applicable.
   */
  C finalizeComponent(B component);

  void addChildren(B component, List<C> children);
}
```
