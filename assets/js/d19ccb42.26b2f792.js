"use strict";(globalThis.webpackChunkdocs_component_markup=globalThis.webpackChunkdocs_component_markup||[]).push([[255],{3106:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"types","title":"Types","description":"In general, tags only statically differentiate between two types: expression and markup. If an expression is assigned to a markup-attribute or vice-versa, parsing will fail as to protect the user from errors during interpretation. All expression-values are interpreted however the tag at hand see fit, with proper fallbacks and console-logs, such that no functionality-inhibitative error may ever occur.","source":"@site/docs/types.mdx","sourceDirName":".","slug":"/types","permalink":"/docs-component-markup/docs/types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Consumer API","permalink":"/docs-component-markup/docs/consumer_api"},"next":{"title":"Built-In Tags","permalink":"/docs-component-markup/docs/category/built-in-tags"}}');var s=r(4848),t=r(8453),l=r(1119),i=r(7420);const o={sidebar_position:8},c="Types",d={},h=[{value:"Markup",id:"markup",level:2},{value:"String",id:"string",level:2},{value:"Color",id:"color",level:2},{value:"Ampersand Sequences",id:"ampersand-sequences",level:3},{value:"Ansi Colors",id:"ansi-colors",level:3},{value:"Hex Colors",id:"hex-colors",level:3},{value:"Boolean",id:"boolean",level:2},{value:"Number",id:"number",level:2},{value:"The ValueInterpreter",id:"the-valueinterpreter",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"types",children:"Types"})}),"\n",(0,s.jsx)(n.p,{children:"In general, tags only statically differentiate between two types: expression and markup. If an expression is assigned to a markup-attribute or vice-versa, parsing will fail as to protect the user from errors during interpretation. All expression-values are interpreted however the tag at hand see fit, with proper fallbacks and console-logs, such that no functionality-inhibitative error may ever occur."}),"\n",(0,s.jsx)(n.h2,{id:"markup",children:"Markup"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(l.H,{type:i.j.MARKUP})," type refers to the main language of this system, namely ",(0,s.jsx)(n.a,{href:"./tag_syntax",children:"Tag Syntax"})," - i.e. an arbitrarily complex construction of tags and attributes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<bold>\n  <red>This text is red!</><br/>\n  <aqua>This text is aqua!</><br/>\n  <blue>This text is blue!</><br/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"This exact, full and unrestricted markup may not just be either at the top level, or at the contents of another tag, but also be an attribute-value, as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<hover-text\n  value={\n    <bold>\n      <red>This text is red!</><br/>\n      <aqua>This text is aqua!</><br/>\n      <blue>This text is blue!</><br/>\n  }\n><aqua>My text\n"})}),"\n",(0,s.jsx)(n.p,{children:"Which, of course, also includes let-bindings, as to create reusable components."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<container\n  *let-my_component={\n    <bold>\n      <red>This text is red!</><br/>\n      <aqua>This text is aqua!</><br/>\n      <blue>This text is blue!</><br/>\n  }\n>{my_component}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"string",children:"String"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(l.H,{type:i.j.STRING})," type simply represents a sequence of characters, which can either be a direct and static attribute-value"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:'<translate key="I am a static string!"/>\n'})}),"\n",(0,s.jsx)(n.p,{children:"or the result of an expression interpreted as a string, where expression-strings are equivalent to markup-strings"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<translate [key]=\"'I am a static string!'\"/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"allowing for dynamic construction of arbitrary complexity"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<translate key=`Prefix {my_variable} suffix`/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Whenever markup-numbers or booleans are specified, their values are stringified if the underlying attribute requires a string-value, such that"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<translate key=512/>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["becomes ",(0,s.jsx)(n.code,{children:'l-me: "512"'})," and"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<translate key/>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["becomes ",(0,s.jsx)(n.code,{children:'l-me: "true"'}),", while its counterpart"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<translate key=false/>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["becomes ",(0,s.jsx)(n.code,{children:'l-me: "false"'}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"color",children:"Color"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(l.H,{type:i.j.COLOR})," type operates on the ",(0,s.jsx)(l.H,{type:i.j.STRING})," type by stringifying whatever value is provided, to then interpret that result as a color-value. There are multiple accepted color-formats, as follows."]}),"\n",(0,s.jsx)(n.h3,{id:"ampersand-sequences",children:"Ampersand Sequences"}),"\n",(0,s.jsxs)(n.p,{children:["So-called legacy colors, of format ",(0,s.jsx)(n.code,{children:"&"})," followed by ",(0,s.jsx)(n.code,{children:"a-f"})," or ",(0,s.jsx)(n.code,{children:"0-9"}),", can directly be provided as colors, just like they are supported as ",(0,s.jsx)(n.a,{href:"./built_in/style#color-shorthands",children:"Color-Shorthands"})," on tags."]}),"\n",(0,s.jsx)(n.h3,{id:"ansi-colors",children:"Ansi Colors"}),"\n",(0,s.jsxs)(n.p,{children:["Every ampersand-sequence corresponds to an Ansi-Color name, e.g. ",(0,s.jsx)(n.code,{children:"&b"})," being named ",(0,s.jsx)(n.code,{children:"aqua"}),"; these names may also be provided as a color, and are again documented at the shorthands-reference above."]}),"\n",(0,s.jsx)(n.h3,{id:"hex-colors",children:"Hex Colors"}),"\n",(0,s.jsxs)(n.p,{children:["Last but not least, the full range of colors is made available via what is known as a hexadecimal color sequence - namely a hashtag ",(0,s.jsx)(n.code,{children:"#"})," followed up by two hexadecimal (",(0,s.jsx)(n.code,{children:"0-9"})," and ",(0,s.jsx)(n.code,{children:"A-F"}),") digits for each red, green and blue component, making for a final scheme of ",(0,s.jsx)(n.code,{children:"#RRGGBB"}),". Whenever an alpha-channel, meaning translucency, is supported, two more digits representing said alpha-value may be appended, i.e. ",(0,s.jsx)(n.code,{children:"#RRGGBBAA"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"boolean",children:"Boolean"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(l.H,{type:i.j.BOOLEAN})," type may either be directly supplied via markup (flag-style) attribute-values, i.e."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<my-tag boolean-attribute />\n"})}),"\n",(0,s.jsx)(n.p,{children:"or"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<my-tag boolean-attribute=false />\n"})}),"\n",(0,s.jsx)(n.p,{children:"or expression-literals, i.e."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:'<my-tag [boolean-attribute]="true" />\n'})}),"\n",(0,s.jsx)(n.p,{children:"or"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:'<my-tag [boolean-attribute]="false" />\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When providing a ",(0,s.jsx)(l.H,{type:i.j.STRING})," type, it becomes ",(0,s.jsx)(n.code,{children:"l-me: true"})," when equaling to ",(0,s.jsx)(n.code,{children:"l-me: 'true'"}),", ",(0,s.jsx)(n.code,{children:"l-me: false"})," when equaling to ",(0,s.jsx)(n.code,{children:"l-me: 'false'"})," and in all other cases, ",(0,s.jsx)(n.code,{children:"l-me: true"})," if non-empty. When providing a ",(0,s.jsx)(l.H,{type:i.j.NUMBER}),", ",(0,s.jsx)(n.code,{children:"l-me: true"})," is only achieved for values not equal to ",(0,s.jsx)(n.code,{children:"l-me: 0"}),". Also, ",(0,s.jsx)(n.code,{children:"l-me: null"}),"-values always result in ",(0,s.jsx)(n.code,{children:"l-me: false"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"number",children:"Number"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(l.H,{type:i.j.NUMBER})," type accepts either whole numbers (longs)"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<my-tag numeric-attribute=512/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"or fractional numbers (doubles)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-component-markup",children:"<my-tag numeric-attribute=3.141592/>\n"})}),"\n",(0,s.jsx)(n.p,{children:"where if an attribute operates on whole numbers only, decimal digits will be truncated."}),"\n",(0,s.jsxs)(n.p,{children:["When providing a ",(0,s.jsx)(l.H,{type:i.j.BOOLEAN}),", ",(0,s.jsx)(n.code,{children:"l-me: true"})," yields ",(0,s.jsx)(n.code,{children:"l-me: 1"})," and ",(0,s.jsx)(n.code,{children:"l-me: false"})," yields ",(0,s.jsx)(n.code,{children:"l-me: 0"}),". When providing a ",(0,s.jsx)(l.H,{type:i.j.STRING}),", the system tries to parse it as a number, meaning that ",(0,s.jsx)(n.code,{children:"l-me: '512'"})," will become ",(0,s.jsx)(n.code,{children:"l-me: 512"}),"; malformed numbers result in ",(0,s.jsx)(n.code,{children:"l-me: 0"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-valueinterpreter",children:"The ValueInterpreter"}),"\n",(0,s.jsxs)(n.p,{children:["The behavior of interpreting one type as another is defined by the ",(0,s.jsx)(n.code,{children:"ValueInterpreter"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"public interface ValueInterpreter {\n\n  long asLong(@Nullable Object value);\n\n  double asDouble(@Nullable Object value);\n\n  @NotNull Number asLongOrDouble(@Nullable Object value);\n\n  boolean asBoolean(@Nullable Object value);\n\n  @NotNull String asString(@Nullable Object value);\n\n  @NotNull List<Object> asList(@Nullable Object value);\n\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There's a default implementation provided with every instance of the ",(0,s.jsx)(n.code,{children:"InterpretationEnvironment"}),", which can be overridden by a custom version using the environment's builder-functions; this is not recommended, since users should be able to predict interpretation as to reduce mental overhead - yet, this feature is kept for power-users."]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);