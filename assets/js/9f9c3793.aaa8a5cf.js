"use strict";(self.webpackChunkdocs_component_markup=self.webpackChunkdocs_component_markup||[]).push([[268],{6711:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"extension_api","title":"Extension API","description":"This system has been designed with flexibility as well as extensibility in mind from the very get-go. On this","source":"@site/docs/extension_api.mdx","sourceDirName":".","slug":"/extension_api","permalink":"/docs-component-markup/docs/extension_api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Expression Syntax","permalink":"/docs-component-markup/docs/expression_syntax"},"next":{"title":"Platform API","permalink":"/docs-component-markup/docs/platform_api"}}');var r=t(4848),a=t(8453),s=t(6025);const o={sidebar_position:4},l="Extension API",d={},c=[{value:"Defining Tags",id:"defining-tags",level:2},{value:"Matching Names",id:"matching-names",level:2},{value:"Creating Nodes",id:"creating-nodes",level:2},{value:"Retrieving Attributes",id:"retrieving-attributes",level:2},{value:"Interpreter Interception",id:"interpreter-interception",level:2},{value:"Interception Lifecycle",id:"interception-lifecycle",level:3},{value:"Interpreter Reference",id:"interpreter-reference",level:3},{value:"Temporary Variables",id:"temporary-variables",level:3},{value:"Creating/Modifying Components",id:"creatingmodifying-components",level:3},{value:"Emitting To Output",id:"emitting-to-output",level:3},{value:"Deferred Content",id:"deferred-content",level:2},{value:"Advantages",id:"advantages",level:3},{value:"The Deferred Node",id:"the-deferred-node",level:3},{value:"Example",id:"example",level:3}];function p(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"extension-api",children:"Extension API"})}),"\n",(0,r.jsx)(n.p,{children:"This system has been designed with flexibility as well as extensibility in mind from the very get-go. On this\npage, the available API usable to define tags and thus AST-nodes as well as to intercept interpretation at\nruntime will be documented. Let's look at an abstract overview-diagram regarding the flow of data first:"}),"\n",(0,r.jsx)("img",{className:"rendered-image",style:{width:"100%"},src:(0,s.Ay)("/img/overview_diagram.svg")}),"\n",(0,r.jsx)(n.h2,{id:"defining-tags",children:"Defining Tags"}),"\n",(0,r.jsx)(n.p,{children:"While a tag-definition may look deceptively simple at first glance, the possibilities it brings to the table\ncannot be overstated."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public abstract class TagDefinition {\n\n  public final TagClosing tagClosing;\n  public final TagPriority tagPriority;\n\n  protected TagDefinition(TagClosing tagClosing, TagPriority tagPriority) {\n    this.tagClosing = tagClosing;\n    this.tagPriority = tagPriority;\n  }\n\n  public abstract boolean matchName(StringView tagName);\n\n  public abstract @NotNull MarkupNode createNode(\n    @NotNull StringView tagName,\n    @NotNull AttributeMap attributes,\n    @Nullable LinkedHashSet<LetBinding> letBindings,\n    @Nullable List<MarkupNode> children\n  );\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The above represents the template provided in order to define a new tag, to be registered\nin and used with an instance of the ",(0,r.jsx)(n.code,{children:"TagRegistry"}),". Immediately within the ",(0,r.jsx)(n.code,{children:"super"}),"-constructor,\nthe tag closing-type"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public enum TagClosing {\n  // <my-tag>Content</>\n  OPEN_CLOSE,\n  // <my-tag/>\n  SELF_CLOSE,\n  // Either or - supporting both\n  INVARIANT,\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["is to be defined, where self-closing tags may not bear any content and thereby will always\nreceive a ",(0,r.jsx)(n.code,{children:"children"}),"-list of ",(0,r.jsx)(n.code,{children:"null"}),"; next up, a tag-priority"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public enum TagPriority {\n  // v- Picked first\n  HIGHEST,\n  HIGH,\n  // v- Baseline\n  NORMAL,\n  LOW,\n  LOWEST,\n  // ^- Picked last\n}\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"will signal which definition to pick if a tag's name matched on multiple registered definitions,\nallowing the user to override built-in behavior (although not necessarily recommended) to any\ngranularity. These already are the only properties required upfront, where name- and attribute-\nmatching remain completely dynamic."}),"\n",(0,r.jsx)(n.h2,{id:"matching-names",children:"Matching Names"}),"\n",(0,r.jsxs)(n.p,{children:["Due to the fact that names are not to be specified ahead of time, a tag-definition may handle\npatterns of arbitrary complexity, as is the case with ",(0,r.jsx)(n.a,{href:"./built_in/style#color-shorthands",children:"Color Shorthands"}),". Also, in general, tag- as well as attribute-names are case-insensitive.\nOnce ",(0,r.jsx)(n.code,{children:"matchName"})," returned ",(0,r.jsx)(n.code,{children:"true"})," for one such given name, the tag-definition becomes a candidate\nwithin the list of possible handlers, from which the one of highest priority will prevail."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-nodes",children:"Creating Nodes"}),"\n",(0,r.jsxs)(n.p,{children:["As soon as the system completed parsing the a tag in its entirety, including attributes as\nwell as possibly some content, ",(0,r.jsx)(n.code,{children:"createNode"})," will be invoked (with the very same name matched\nupon earlier, for reference), whose responsibility it is to instantiate an AST-node,\nbeing a derivative of a ",(0,r.jsx)(n.code,{children:"MarkupNode"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public abstract class MarkupNode {\n\n  public @Nullable ExpressionNode ifCondition;\n  public @Nullable ExpressionNode useCondition;\n\n  public final StringView positionProvider;\n\n  public @Nullable List<MarkupNode> children;\n  public @Nullable LinkedHashSet<LetBinding> letBindings;\n\n  public MarkupNode(\n    StringView positionProvider,\n    @Nullable List<MarkupNode> children,\n    @Nullable LinkedHashSet<LetBinding> letBindings\n  ) {\n    this.positionProvider = positionProvider;\n    this.children = children;\n    this.letBindings = letBindings;\n  }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The base class already takes care of holding the ",(0,r.jsx)(n.code,{children:"position"}),", as well as optional lists of ",(0,r.jsx)(n.code,{children:"children"})," and\n",(0,r.jsx)(n.code,{children:"letBindings"})," (see ",(0,r.jsx)(n.a,{href:"./tag_syntax#let-bindings",children:"Let-Bindings"}),"). This immediately implies that tags may\nimplicitly define bindings or modify child-entries. While there are many pre-defined node-types available,\nusers may also always define their own, handled via ",(0,r.jsx)(n.a,{href:"#interpreter-interception",children:"Interpreter-Interception"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"retrieving-attributes",children:"Retrieving Attributes"}),"\n",(0,r.jsxs)(n.p,{children:["The astute reader might have noticed that up until this point, no attributes have ever been defined\nanywhere - and for good reason: keeping a single source of truth, paired with flexibility. The ",(0,r.jsx)(n.code,{children:"AttributeMap"}),",\nas passed into ",(0,r.jsx)(n.code,{children:"createNode"}),", handles access in a somewhat unusual, yet beautifully simplistic manner; let's\ntake a look at its API first:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface AttributeMap {\n\n  // v- Attributes of type expression\n\n  @NotNull ExpressionNode getMandatoryExpressionNode(String name, String... aliases);\n\n  @Nullable ExpressionNode getOptionalExpressionNode(String name, String... aliases);\n\n  @NotNull ExpressionList getMandatoryExpressionList(String name, String... aliases);\n\n  @NotNull ExpressionList getOptionalExpressionList(String name, String... aliases);\n\n  // v- Attributes of type markup\n\n  @NotNull MarkupNode getMandatoryMarkupNode(String name, String... aliases);\n\n  @Nullable MarkupNode getOptionalMarkupNode(String name, String... aliases);\n\n  @NotNull MarkupList getMandatoryMarkupList(String name, String... aliases);\n\n  @NotNull MarkupList getOptionalMarkupList(String name, String... aliases);\n\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["There are two different types of attributes - ",(0,r.jsx)(n.a,{href:"./expression_syntax",children:"Expressions"})," as well as a sub-tree of\n",(0,r.jsx)(n.a,{href:"./tag_syntax",children:"Markup"}),", both bound to an identifying ",(0,r.jsx)(n.code,{children:"name"}),", where a name can only ever depict one and the\nsame type used as an internal representation of the data associated with it. Optional attributes are not required\nto be present in order for the construction of the corresponding tag to succeed, while their mandatory\ncounterparts certainly are, failing parsing if absent; single values (nodes) may be null if omitted, while lists\nare always non-null, for convenience. When requiring an attribute as a list, this simply means that it may be\nspecified more than once, and could possibly be bound using the spread-operator ",(0,r.jsx)(n.code,{children:"..."}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The above instantly implies the possibility of dynamic attributes like:\n",(0,r.jsx)(n.code,{children:"Y exists and is mandatory if and only if X is present"}),", as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'ExpressionNode xValue = attributes.getOptionalExpressionNode("x");\n\nif (xValue != null) {\n  ExpressionNode yValue = attributes.getMandatoryExpressionNode("y");\n  // TODO: Handle case 2\n}\n\nelse {\n  // TODO: Handle case 1\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["After ",(0,r.jsx)(n.code,{children:"constructNode"})," responded with a result, the ",(0,r.jsx)(n.code,{children:"AttributeMap"})," is internally checked for any unused\nattributes and, if any, will fail parsing, telling the user that they've specified unsupported (at\nleast in their current attribute-constellation) names. This way, a tag can access attributes of exact\ntypes and names as desired, not having to take the burden of validation, without compromising on clarity\nwhen it comes to user-facing error-screens."]}),"\n",(0,r.jsxs)(n.p,{children:["Lists of attributes are intentionally represented as an internal wrapper, due to the fact that they may be\ndynamically bound, using the spread-operator ",(0,r.jsx)(n.code,{children:"..."}),", which entails that the elements may not be known at\nparse-time; such a list is supposed to be stored inside the constructed node as-is, to be evaluated later\nduring interpretation, using the concept of ",(0,r.jsx)(n.a,{href:"#interpreter-interception",children:"Interpreter-Interception"}),"; they are\naccessed by providing a reference to the interpreter, as follows:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface MarkupList {\n\n  boolean isEmpty();\n\n  List<MarkupNode> get(Interpreter interpreter);\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"and"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface ExpressionList {\n\n  boolean isEmpty();\n\n  List<ExpressionNode> get(Interpreter interpreter);\n\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interpreter-interception",children:"Interpreter Interception"}),"\n",(0,r.jsxs)(n.p,{children:["Many features require interception at the time of interpretation in order to be implemented; in fact, that's\nexactly how - for example - the ",(0,r.jsx)(n.a,{href:"./built_in/rainbow",children:"Rainbow-Tag"})," operates, by cancelling default processing\nof the elements it targets, while emitting its own colorized members into the final output."]}),"\n",(0,r.jsx)(n.h3,{id:"interception-lifecycle",children:"Interception Lifecycle"}),"\n",(0,r.jsxs)(n.p,{children:["Registering to be called for interception is again as simple as it gets: once the node as constructed by\n",(0,r.jsx)(n.code,{children:"constructNode"})," implements the following interface, it will be called when it itself is encountered, as well\nas for every of its children:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface InterpreterInterceptor {\n\n  InterceptionResult interceptInterpretation(MarkupNode node, Interpreter interpreter);\n\n  void afterInterpretation(MarkupNode node, Interpreter interpreter);\n\n  void onSkippedByChild(MarkupNode node, Interpreter interpreter, InterceptionResult priorResult);\n\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The main point of control, ",(0,r.jsx)(n.code,{children:"interceptInterpretation"}),", may result in one of the following signals:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public enum InterceptionResult {\n  DO_NOT_PROCESS,\n  DO_PROCESS_AND_CALL_AFTER,\n  DO_PROCESS\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When instructing the interpreter to not process the current node, it will be skipped over in its entirety -\nincluding whichever children it may have contained. In order to only render said members partially, make use\nof the provided reference to the interpreter as to emit nodes manually; in most cases, processing will only\nbe inhibited for terminal nodes though, which are then overridden by custom instances, emitted once again\nmanually, while ",(0,r.jsx)(n.code,{children:"DO_PROCESS_AND_CALL_AFTER"})," makes for a perfect way to keep a ",(0,r.jsx)(n.code,{children:"ThreadLocal"})," stack within the\nAST-node itself, handling state of the feature which leverages interception."]}),"\n",(0,r.jsx)(n.p,{children:"Let's look at an example of concurrent interceptors; even though per tag and thus per node, only at most a\nsingle interceptor may be registered at a time, there may be multiple interceptors in charge at any given\ndepth. Due to this naturally arising mechanism, interceptors are kept on a stack, from which they are popped\nas soon as the scope of their corresponding tag ends; also, interceptors who registered first (outermost tags)\nalways take precedence by being invoked first. A parent may skip a child's possibility of interception, such\nthat it is not even called into; also, a child may skip a node which a parent did allow to process:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<a> \x3c!-- begin scope A --\x3e\n  <b> \x3c!-- begin scope B --\x3e\n    <c> \x3c!-- begin scope C --\x3e\n      ...\n    </c> \x3c!-- end scope C --\x3e\n  </b> \x3c!-- end scope B --\x3e\n</a> \x3c!-- end scope A --\x3e\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"l-cm: <a>"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"A"}),": ",(0,r.jsx)(n.code,{children:"DO_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Registers interceptor ",(0,r.jsx)(n.code,{children:"A"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"l-cm: <b>"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"A"}),": ",(0,r.jsx)(n.code,{children:"DO_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"B"}),": ",(0,r.jsx)(n.code,{children:"DO_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Registers interceptor ",(0,r.jsx)(n.code,{children:"B"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"l-cm: <c>"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"A"}),": ",(0,r.jsx)(n.code,{children:"DO_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"B"}),": ",(0,r.jsx)(n.code,{children:"DO_PROCESS_AND_CALL_AFTER"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calls interceptor ",(0,r.jsx)(n.code,{children:"C"}),": ",(0,r.jsx)(n.code,{children:"DO_NOT_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.code,{children:"onSkippedByChild"})," of ",(0,r.jsx)(n.code,{children:"A"})," with ",(0,r.jsx)(n.code,{children:"DO_PROCESS"})]}),"\n",(0,r.jsxs)(n.li,{children:["Calls ",(0,r.jsx)(n.code,{children:"onSkippedByChild"})," of ",(0,r.jsx)(n.code,{children:"B"})," with ",(0,r.jsx)(n.code,{children:"DO_PROCESS_AND_CALL_AFTER"})]}),"\n",(0,r.jsxs)(n.li,{children:["Does not register ",(0,r.jsx)(n.code,{children:"C"})," (as it skipped itself)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"interpreter-reference",children:"Interpreter Reference"}),"\n",(0,r.jsx)(n.p,{children:"With the lifecycle as described above in mind, an interceptor is now fully enabled to interpret expressions,\nintroduce temporary variables, interpret markup subtrees, construct platform-specific components and emit to\nthe output, all thanks to the provided interpreter-reference:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface Interpreter {\n\n  TemporaryMemberEnvironment getEnvironment();\n\n  @NotNull String evaluateAsString(@Nullable ExpressionNode expression);\n\n  @Nullable String evaluateAsStringOrNull(@Nullable ExpressionNode expression);\n\n  long evaluateAsLong(@Nullable ExpressionNode expression);\n\n  @Nullable Long evaluateAsLongOrNull(@Nullable ExpressionNode expression);\n\n  double evaluateAsDouble(@Nullable ExpressionNode expression);\n\n  @Nullable Double evaluateAsDoubleOrNull(@Nullable ExpressionNode expression);\n\n  @NotNull Number evaluateAsLongOrDouble(@Nullable ExpressionNode expressionNode);\n\n  @Nullable Number evaluateAsLongOrDoubleOrNull(@Nullable ExpressionNode expressionNode);\n\n  boolean evaluateAsBoolean(@Nullable ExpressionNode expression);\n\n  TriState evaluateAsTriState(@Nullable ExpressionNode expression);\n\n  @Nullable Object evaluateAsPlainObject(@Nullable ExpressionNode expression);\n\n  boolean interpret(MarkupNode node);\n\n  boolean interpret(MarkupNode node, @Nullable Runnable afterScopeBegin);\n\n  OutputBuilder getCurrentBuilder();\n\n  ComponentConstructor getComponentConstructor();\n\n  int getCurrentSubtreeDepth();\n\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"temporary-variables",children:"Temporary Variables"}),"\n",(0,r.jsx)(n.p,{children:"In order to introduce temporary variables, update- and remove them again, there's an environment-accessor\nwithin the interpreter, providing a way to modify the temporary-variable-stack:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface TemporaryMemberEnvironment extends InterpretationEnvironment {\n\n  void beginScope();\n\n  void endScope();\n\n  void setScopeVariable(String name, Object value);\n\n  InterpretationEnvironment snapshot();\n\n  void forEachKnownName(Consumer<String> handler);\n\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["When introducing variable-values which are modified by reference later on, as is the case with the ",(0,r.jsx)(n.code,{children:"loop"}),"-variable\nwhich the intrinsic ",(0,r.jsx)(n.code,{children:"*for"})," attribute introduces, they should implement the following interface, as to allow the\nsystem to create a static copy to be used when snapshotting the environment for deferred components or captures."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface InternalCopyable {\n\n  Object copy();\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:'In order to avoid having to make use of reflection whenever accessing members of objects within expressions\nwith the member-operator, the following interface - if implemented on the object accessed into - is called first, as to directly access\nnamed fields; it also doubles as a means to define arbitrarily complex "getters".'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface DirectFieldAccess {\n\n  Object UNKNOWN_FIELD_SENTINEL = new Object();\n\n  @Nullable Object accessField(String rawIdentifier);\n\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creatingmodifying-components",children:"Creating/Modifying Components"}),"\n",(0,r.jsxs)(n.p,{children:["Components, as created by invoking the ",(0,r.jsx)(n.code,{children:"OutputBuilder"})," with AST-nodes, may be modified to any degree using the\nplatform-specific ",(0,r.jsx)(n.code,{children:"ComponentConstructor"}),"; next to modifying existing components, custom components may also be\nconstructed from the ground up using nothing but their parameters, to be emitted directly later on. Learn more\nabout this class over at the ",(0,r.jsx)(n.a,{href:"./platform_api",children:"Platform-API"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"emitting-to-output",children:"Emitting To Output"}),"\n",(0,r.jsx)(n.p,{children:"When it comes to emitting intercepted or even custom elements to the final output, the following\nreference, as provided by the interpreter, allows for much flexibility:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface OutputBuilder {\n\n  void onBreak();\n\n  void onNonTerminalBegin(MarkupNode nonTerminal);\n\n  @Nullable Object onNonTerminalEnd();\n\n  void onText(TextNode node, @Nullable Consumer<Object> creationHandler, boolean doNotBuffer);\n\n  Object onUnit(UnitNode node);\n\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"deferred-content",children:"Deferred Content"}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"Deferred content is still not entirely nailed down and thus considered experimental."})}),"\n",(0,r.jsx)(n.p,{children:"The concept of deferred components represents another stage of templating: tayloring content\nto the specific recipient it's sent to. If this information is already available at the time\nof interpretation, the recipient may be passed to the call of the interpreter, causing deferred\ncomponents to render immediately, as they now have access to the recipient-reference; otherwise,\nthe result will contain one or more instances of a custom derivative of the platform's native\ncomponent which essentially contains a context-closure that calls back into the deferred node\nonce said reference is provided later on, right before sending/applying the component."}),"\n",(0,r.jsx)(n.p,{children:"This concept solves the entire headache of server-side rendered (SSR) components, which simplifies\nplatform-implementations by a great deal without having to compromise on available features;\nquite the opposite - we may introduce whichever SSR-tags and features that prove beneficial\nin a version-agnostic manner. Usually, these include: NBT-data, selectors, score-values and\nthe like."}),"\n",(0,r.jsx)(n.h3,{id:"advantages",children:"Advantages"}),"\n",(0,r.jsx)(n.p,{children:"The main advantage deferred content has over simply employing environment-variables to interpret\nASTs on a per-recipient basis is that this way, non-tailored components are constructed only once,\ninstead of over and over again, yielding the exact same result each time; think of it as a partially\ncached tree. To ensure further efficiency, the paths to deferred components within the result are\nstored on a type of prefix-tree, avoiding to needlessly walk all children; once deferred components\nare invoked, their result is spliced into the final output by cloning along the necessary paths, leaving\nthe immutable template untouched."}),"\n",(0,r.jsx)(n.h3,{id:"the-deferred-node",children:"The Deferred Node"}),"\n",(0,r.jsx)(n.p,{children:"How does a tag register itself as being deferred? It simply emits a partial tree which either is- or\ncontains a deferred node, where such a node has to be able to create a parameter to be stored within\nthe closure, as well as to render the deferred placeholder as concrete and tailored components."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public abstract class DeferredNode<Parameter extends RendererParameter> extends UnitNode implements DeferredRenderer<Parameter> {\n\n  public DeferredNode(int position, @Nullable LinkedHashSet<LetBinding> letBindings) {\n    super(position, letBindings);\n  }\n\n  public abstract Parameter createParameter(Interpreter interpreter);\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"While the parameter may be of whatever desired type, it is considered good practise to implement a proper\nplain-text representation which is substituted whenever raw (non-substituted) results are applied/sent such\nthat the API-user knows that they forgot to pass a receiver-reference before applying said result;\nthis may also be rather handy when debugging one's template and while developing the system in general."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface RendererParameter {\n\n  String asPlainText();\n\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The deferred renderer receives the parameter constructed prior, a reference to the component-constructor, the\ncontext of the slot which it is rendered into, as to simply pass on to the interpreter (if required) to ensure\nproper reset-behavior, as well as a snapshot of the environment containing the state at the point in time of the\ncorresponding tag within the cycle of interpretation. All of this information allows for seamless integration."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface DeferredRenderer<Parameter extends RendererParameter> {\n\n  /**\n   * @return A list of components, where (if supported by the slot) each represents\n   *         another line; return null to become invisible (no content).\n   */\n  @Nullable List<Object> renderComponent(\n    Parameter parameter,\n    ComponentConstructor componentConstructor,\n    InterpretationEnvironment environment,\n    SlotContext slotContext,\n    @Nullable Object recipient\n  );\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Let's implement a very simple tag called ",(0,r.jsx)(n.code,{children:"l-cm: <player-name/>"}),", starting out by defining a parameter\nwhich just captures whether to use the display-name or the plain account-name."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PlayerNameParameter implements RendererParameter {\n\n  public boolean displayName;\n\n  public PlayerNameParameter(boolean displayName) {\n    this.displayName = displayName;\n  }\n\n  @Override\n  public String asPlainText() {\n    return "PlayerName{displayName=" + displayName + "}";\n  }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Next up, by deriving the ",(0,r.jsx)(n.code,{children:"DeferredNode"}),", we prepare for defining the corresponding tag - its attributes\nwill feed into the constructor of this class, allowing for not only the aforementioned display-name\nflag, but also to provide a custom markup-renderer."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PlayerNameNode extends DeferredNode<PlayerNameParameter> {\n\n  public final @Nullable ExpressionNode displayName;\n  public final @Nullable MarkupNode renderer;\n\n  public PlayerNameNode(\n    @Nullable ExpressionNode displayName,\n    @Nullable MarkupNode renderer,\n    int position,\n    @Nullable LinkedHashSet<LetBinding> letBindings\n  ) {\n    super(position, letBindings);\n\n    this.displayName = displayName;\n    this.renderer = renderer;\n  }\n\n  @Override\n  public @Nullable List<Object> renderComponent(\n    PlayerNameParameter parameter,\n    ComponentConstructor componentConstructor,\n    InterpretationEnvironment environment,\n    SlotContext slotContext,\n    @Nullable Object recipient\n  ) {\n    if (recipient == null)\n      return null;\n\n    DeferredDataProvider provider = componentConstructor.getDataProvider();\n    String name = parameter.displayName ? provider.getDisplayName(recipient) : provider.getName(recipient);\n\n    if (renderer == null)\n      return Collections.singletonList(componentConstructor.createTextComponent(name));\n\n    // v- Do not modify the component of the closure, as it may be reused!\n    environment = environment.copy().withVariable("player_name", name);\n\n    //    Deferred content allows for fully fledged markup!\n    //    By passing the recipient directly to the interpreter, deeply nested deferred tags\n    //    will render immediately, assuring that the unprocessed components will not contain\n    //    any more closures - because all information is available right now anyways. This\n    // v- allows for a great deal of reusable and context-insensitive templating.\n    return MarkupInterpreter.interpret(\n      componentConstructor, environment, recipient, slotContext, renderer\n    ).unprocessedComponents;\n  }\n\n  @Override\n  public PlayerNameParameter createParameter(Interpreter interpreter) {\n    return new PlayerNameParameter(interpreter.evaluateAsBoolean(this.displayName));\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Last but not least, the tag can be defined, which now constructs the node above, thereby\nregistering deferred content."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:'public class PlayerNameTag extends TagDefinition {\n\n  public PlayerNameTag() {\n    super(TagClosing.SELF_CLOSE, TagPriority.NORMAL);\n  }\n\n  @Override\n  public boolean matchName(StringView tagName) {\n    return tagName.contentEquals("player-name", true);\n  }\n\n  @Override\n  public @NotNull MarkupNode createNode(\n    @NotNull StringView tagName,\n    @NotNull AttributeMap attributes,\n    @Nullable LinkedHashSet<LetBinding> letBindings,\n    @Nullable List<MarkupNode> children\n  ) {\n    return new PlayerNameNode(\n      attributes.getOptionalExpressionNode("display-name"),\n      attributes.getOptionalMarkupNode("renderer"),\n      tagName, letBindings\n    );\n  }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"When rendering the tag, it works as expected - especially with monochrome color."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<gray>Hello, <aqua><player-name/></>! :)\n"})}),"\n",(0,r.jsx)("img",{className:"rendered-image",src:(0,s.Ay)("/img/deferred_example_monochrome.png")}),"\n",(0,r.jsx)(n.p,{children:"If gradients or rainbows are to be applied, they will not be able to take effect as expected,\nsince the deferred node is represented by a single component at the time of interpretation,\nwhich does not yet know the content and thus its length - making it be an atomic unit."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<gray>Hello, <rainbow><player-name/></>! :)\n"})}),"\n",(0,r.jsx)("img",{className:"rendered-image",src:(0,s.Ay)("/img/deferred_example_rainbow_outer.png")}),"\n",(0,r.jsxs)(n.p,{children:["For this exact reason, the renderer allows to interpret custom markup at the time of\nsubstituting deferred content - now, rainbows apply properly. This style of implementation\nallows for much flexibility, like to provide custom representations for retrieved data. As\ncan be seen in the implementation of the corresponding node above, the variable ",(0,r.jsx)(n.code,{children:"player_name"}),"\nis introduced, containing the resolved value to be visualised however desired."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<gray>Hello, <player-name renderer={ <rainbow>{player_name} } />! :)\n"})}),"\n",(0,r.jsx)("img",{className:"rendered-image",src:(0,s.Ay)("/img/deferred_example_rainbow_inner.png")}),"\n",(0,r.jsx)(n.p,{children:'The environment (which includes all temporary variables) is captured at the\npoint in time during interpretation at which the corresponding deferred tag resides, which is\nalso passed down into the render-method - thus, "outer" variables are easily accessible. This\ncombination allows for flexible and uniform markup across multiple stages of evaluation.'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<gray *let-my_var=\"'test'\">Hello,<space/>\n  <player-name\n    renderer={ <rainbow>{player_name}</>, <red>{my_var} }\n  />! :)\n"})}),"\n",(0,r.jsx)("img",{className:"rendered-image",src:(0,s.Ay)("/img/deferred_example_environment_snapshot.png")})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);