"use strict";(globalThis.webpackChunkdocs_component_markup=globalThis.webpackChunkdocs_component_markup||[]).push([[911],{6669:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"consumer_api","title":"Consumer API","description":"The consumer-facing API has been kept as concise and convenient as humanly possible, in order to be easily","source":"@site/docs/consumer_api.mdx","sourceDirName":".","slug":"/consumer_api","permalink":"/docs-component-markup/docs/consumer_api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Component Constructor","permalink":"/docs-component-markup/docs/component_constructor"},"next":{"title":"Types","permalink":"/docs-component-markup/docs/types"}}');var o=r(4848),a=r(8453);r(6025);const i={sidebar_position:7},s="Consumer API",l={},c=[{value:"Parsing the AST",id:"parsing-the-ast",level:2},{value:"Interpreting the AST",id:"interpreting-the-ast",level:2},{value:"Logging Errors",id:"logging-errors",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"consumer-api",children:"Consumer API"})}),"\n",(0,o.jsx)(n.p,{children:"The consumer-facing API has been kept as concise and convenient as humanly possible, in order to be easily\nintegrateable into whichever approach to managing configuration-files as well as various other day-to-day\nsurroundings the developer at hand may have chosen."}),"\n",(0,o.jsx)(n.h2,{id:"parsing-the-ast",children:"Parsing the AST"}),"\n",(0,o.jsxs)(n.p,{children:["In order to parse an input-string into an ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",children:"AST"}),",\nthe only parameter required is a reference to the tag-registry being used; in the majority of cases, the\nbuilt-in instance will suffice, allowing for quick and easy access:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'try {\n  MarkupNode ast = MarkupParser.parse(InputView.of("<rainbow>Hello, world!"), BuiltInTagRegistry.INSTANCE);\n} catch (MarkupParseException parseException) {\n  for (String line : parseException.makeErrorScreen())\n    LoggerProvider.log(Level.SEVERE, line);\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In general, errors are only thrown during the parsing-stage, with all errors being unified under the\n",(0,o.jsx)(n.code,{children:"MarkupParseException"}),", which is also able to generate a nicely formatted error-screen, for example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'1: <translate\n2:   *let-a="b"\n3:   [key]="my.expr[222 c.d.e"\n----------------------^\nError: Expected a closing-bracket after the indexing-invocation: ]\n4:   fallback={\n5:     hello, {user}\n6:   }\n7: />\n'})}),"\n",(0,o.jsx)(n.p,{children:"Next to the above, there are also many dozens of error-type enumeration-constants all throughout the system,\nstemming from stages like the CML event-parser as well as the expression tokenizer/parser; these are subject\nto change and not considered stable API, which is why next to this mention, they will not be documented."}),"\n",(0,o.jsx)(n.h2,{id:"interpreting-the-ast",children:"Interpreting the AST"}),"\n",(0,o.jsx)(n.p,{children:"Once an input has been successfully parsed, its result as well as all calls to the interpreter are now safe - they\nwill never throw at runtime and instead simply log errors to the console, which are handled as gracefully as\npossible, as to not bring down whatever relied on receiving an output to render."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// Platform-specific reference obtained via the factory\n// TODO: An implementation of said factory still requires more work\nComponentConstructor componentConstructor;\n\n// An instance which has been successfully parsed prior\nMarkupNode ast;\n\nInterpretationEnvironment myEnvironment = new InterpretationEnvironment()\n  .withVariable("first_variable", "hello, world!")\n  .withVariable("second_variable", Math.random());\n\n// TODO: In the future, slot-type decision as well as application will\n//       be handled by a more convenient helper\n\nList<Object> components = MarkupInterpreter.interpret(\n  componentConstructor,\n  myEnvironment,\n  SlotType.CHAT,\n  ast\n);\n\n// The components above may now be manually applied however necessary\n'})}),"\n",(0,o.jsx)(n.h2,{id:"logging-errors",children:"Logging Errors"}),"\n",(0,o.jsxs)(n.p,{children:["Since runtime-errors are handled gracefully, logging is an integral part of this system; thus, the internally\nwidely-used ",(0,o.jsx)(n.code,{children:"GlobalLogger"})," has been introduced, which allows the user to provide a reference of their own\nat any point in time:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'public class GlobalLogger {\n\n  private static Logger logger = Logger.getAnonymousLogger();\n\n  public static void log(Level level, String message, Throwable throwable) {\n    logger.log(level, message, throwable);\n  }\n\n  public static void log(Level level, String message, boolean printStackTrace) {\n    logger.log(level, message);\n\n    if (!printStackTrace)\n      return;\n\n    for (StackTraceElement stackTraceElement : Thread.currentThread().getStackTrace())\n      logger.log(level, "    at " + stackTraceElement);\n  }\n\n  public static void log(Level level, String message) {\n    log(level, message, true);\n  }\n\n  public static void set(Logger logger) {\n    GlobalLogger.logger = logger;\n  }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The above will only log internal errors, meaning actual divergences from expected behavior. When\nit comes to user-errors, such as malformed expressions or invalid tag-usage, these are logged\nseparately, using the dependency-injected ",(0,o.jsx)(n.code,{children:"InterpreterLogger"}),", such that the user of the library\ncan decide how to handle these, for example by prefixing log-lines with additional context, like\nthe path of the corresponding configuration-file on the system."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public interface InterpreterLogger {\n\n  default void logErrorScreen(InputView positionProvider, String message) {\n    log(positionProvider, positionProvider.getPosition(), message, null);\n  }\n\n  default void logErrorScreen(InputView positionProvider, String message, Throwable e) {\n    log(positionProvider, positionProvider.getPosition(), message, null);\n  }\n\n  void log(InputView view, int position, String message, @Nullable Throwable e);\n\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);