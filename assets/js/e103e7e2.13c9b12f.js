"use strict";(self.webpackChunkdocs_component_markup=self.webpackChunkdocs_component_markup||[]).push([[911],{6669:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"consumer_api","title":"Consumer API","description":"The consumer-facing API has been kept as concise and convenient as humanly possible, in order to be easily","source":"@site/docs/consumer_api.mdx","sourceDirName":".","slug":"/consumer_api","permalink":"/docs-component-markup/docs/consumer_api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Extension API","permalink":"/docs-component-markup/docs/extension_api"},"next":{"title":"Built-In Tags","permalink":"/docs-component-markup/docs/category/built-in-tags"}}');var o=r(4848),a=r(8453);r(6025);const s={sidebar_position:5},i="Consumer API",l={},c=[{value:"Parsing the AST",id:"parsing-the-ast",level:2},{value:"Interpreting the AST",id:"interpreting-the-ast",level:2},{value:"Logging Errors",id:"logging-errors",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"consumer-api",children:"Consumer API"})}),"\n",(0,o.jsx)(n.p,{children:"The consumer-facing API has been kept as concise and convenient as humanly possible, in order to be easily\nintegrateable into whichever approach to managing configuration-files as well as various other day-to-day\nsurroundings the developer at hand may have chosen."}),"\n",(0,o.jsx)(n.h2,{id:"parsing-the-ast",children:"Parsing the AST"}),"\n",(0,o.jsxs)(n.p,{children:["In order to parse an input-string into an ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",children:"AST"}),",\nthe only parameter required is a reference to the tag-registry being used; in the majority of cases, the\nbuilt-in instance will suffice, allowing for quick and easy access:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'try {\n  MarkupNode ast = MarkupParser.parse("<rainbow>Hello, world!", BuiltInTagRegistry.INSTANCE);\n} catch (MarkupParseException parseException) {\n  for (String line : parseException.makeErrorScreen())\n    LoggerProvider.get().log(Level.SEVERE, line);\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In general, errors are only thrown during the parsing-stage, with all errors being unified under the\n",(0,o.jsx)(n.code,{children:"MarkupParseException"}),", which is also able to generate a nicely formatted error-screen, for example:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:'1: <translate\n2:   let-a="b"\n3:   [key]="my.expr[222 c.d.e"\n----------------------^\n   Error: Expected a closing-bracket after the indexing-invocation: ]\n4:   fallback={\n5:     hello, {user}\n6:   }\n7: />\n'})}),"\n",(0,o.jsx)(n.p,{children:"Next to the above, there are also many dozens of error-type enumeration-constants all throughout the system,\nstemming from stages like the XML event-parser as well as the expression tokenizer/parser; these are subject\nto change and not considered stable API, which is why next to this mention, they will not be documented."}),"\n",(0,o.jsx)(n.h2,{id:"interpreting-the-ast",children:"Interpreting the AST"}),"\n",(0,o.jsx)(n.p,{children:"Once an input has been successfully parsed, its result as well as all calls to the interpreter are now safe - they\nwill never throw at runtime and instead simply log errors to the console, which are handled as gracefully as\npossible, as to not bring down whatever relied on receiving an output to render."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:'// Platform-specific reference obtained via the factory\n// TODO: An implementation of said factory still requires more work\nComponentConstructor componentConstructor;\n\n// An instance which has been successfully parsed prior\nMarkupNode ast;\n\nInterpretationEnvironment myEnvironment = new InterpretationEnvironment()\n  .withVariable("first_variable", "hello, world!")\n  .withVariable("second_variable", Math.random());\n\n// TODO: In the future, slot-type decision as well as application will\n//       be handled by a more convenient helper\n\nList<Object> components = MarkupInterpreter.interpret(\n  componentConstructor,\n  myEnvironment,\n  SlotType.CHAT,\n  ast\n);\n\n// The components above may now be manually applied however necessary\n'})}),"\n",(0,o.jsx)(n.h2,{id:"logging-errors",children:"Logging Errors"}),"\n",(0,o.jsxs)(n.p,{children:["Since runtime-errors are handled gracefully, logging is an integral part of this system; thus, the internally\nwidely-used ",(0,o.jsx)(n.code,{children:"LoggerProvider"})," has been introduced, which allows the user to provide a reference of their own\nat any point in time:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-java",children:"public class LoggerProvider {\n\n  private static Logger logger = Logger.getAnonymousLogger();\n\n  public static Logger get() {\n    return logger;\n  }\n\n  public static void set(Logger logger) {\n    LoggerProvider.logger = logger;\n  }\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var t=r(6540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);