"use strict";(globalThis.webpackChunkdocs_component_markup=globalThis.webpackChunkdocs_component_markup||[]).push([[340],{1302:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"component_constructor","title":"Component Constructor","description":"This project remains entirely platform-agnostic by working with externally provided implementations of","source":"@site/docs/component_constructor.mdx","sourceDirName":".","slug":"/component_constructor","permalink":"/docs-component-markup/docs/component_constructor","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Extension API","permalink":"/docs-component-markup/docs/extension_api"},"next":{"title":"Consumer API","permalink":"/docs-component-markup/docs/consumer_api"}}');var r=t(4848),i=t(8453);const a={sidebar_position:6},c="Component Constructor",s={},l=[];function p(n){const e={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"component-constructor",children:"Component Constructor"})}),"\n",(0,r.jsxs)(e.p,{children:["This project remains entirely platform-agnostic by working with externally provided implementations of\nthe ",(0,r.jsx)(e.code,{children:"ComponentConstructor"}),", which comes with many benefits, such as the fact that no intermediate representation\nand thus no conversions are necessary - also, proper automated testing can be conducted using independent\nmocks."]}),"\n",(0,r.jsx)(e.p,{children:"In order to construct- and interact with components native to the platform at hand, the\ncomponent-constructor offers various endpoints, allowing the system to unfold the full\nset of features with just a few basic necessities provided."}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-java",children:"/**\n * @param <B> Component(B)uilder - Useful as an intermediate if components are immutable, seeing how\n *            the construction-process inherently depends on in-place alteration; simply let\n *            {@link ComponentConstructor#finalizeComponent(Object)} be a passthrough if the\n *            components on your platform are already mutable.\n * @param <C> (C)omponent - The final, platform-specific result, not to be altered any further.\n */\npublic interface ComponentConstructor<B, C> {\n\n  Class<C> getComponentClass();\n\n  boolean doesSupport(ConstructorFeature feature);\n\n  // ================================================================================\n  // SlotContext\n  // ================================================================================\n\n  SlotContext getSlotContext(SlotType slot);\n\n  // ================================================================================\n  // TerminalNode\n  // ================================================================================\n\n  B createTextComponent(String text);\n\n  /**\n   * @return Whether the component was a text-component and the operation was successful.\n   */\n  boolean setText(B component, String text);\n\n  B createKeyComponent(String key);\n\n  B createTranslateComponent(String key, List<C> with, @Nullable String fallback);\n\n  // ================================================================================\n  // Click-Action\n  // ================================================================================\n\n  void setClickChangePageAction(B component, String value);\n\n  void setClickCopyToClipboardAction(B component, String value);\n\n  void setClickOpenFileAction(B component, String value);\n\n  void setClickOpenUrlAction(B component, String value);\n\n  void setClickRunCommandAction(B component, String value);\n\n  void setClickSuggestCommandAction(B component, String value);\n\n  // ================================================================================\n  // Hover-Action\n  // ================================================================================\n\n  void setHoverItemAction(\n    B component,\n    String material,\n    @Nullable Integer count,\n    @Nullable C name,\n    @Nullable List<C> lore,\n    boolean hideProperties\n  );\n\n  void setHoverTextAction(B component, C text);\n\n  void setHoverEntityAction(B component, String type, UUID id, @Nullable C name);\n\n  // ================================================================================\n  // Insert-Action\n  // ================================================================================\n\n  void setInsertAction(B component, String value);\n\n  // ================================================================================\n  // Styling\n  // ================================================================================\n\n  void setColor(B component, long packedColor, boolean allowOverwrite);\n\n  void setShadowColor(B component, long packedColor);\n\n  void setFont(B component, String font);\n\n  void setObfuscatedFormat(B component, TriState value);\n\n  void setBoldFormat(B component, TriState value);\n\n  void setStrikethroughFormat(B component, TriState value);\n\n  void setUnderlinedFormat(B component, TriState value);\n\n  void setItalicFormat(B component, TriState value);\n\n  // ================================================================================\n  // Children\n  // ================================================================================\n\n  void addChildren(B component, List<C> children);\n\n  // ================================================================================\n  // Miscellaneous\n  // ================================================================================\n\n  /**\n   * Called once a component has been fully constructed and no more changes are to be\n   * made. Since Adventure is deeply immutable and thereby enforces builders, this stage\n   * would call the build method, as to end up with a final component to pass on.\n   * @param component Component to be finalized, as created by the corresponding creation-methods.\n   * @return Finalized component, ready to be used wherever applicable.\n   */\n  C finalizeComponent(B component);\n\n  /**\n   * Recursively walks the provided finalized component and invokes the callback once\n   * for each occurrence of a text-component, which includes the self.\n   */\n  void forEachTextOf(C component, Consumer<String> handler);\n\n}\n"})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(p,{...n})}):p(n)}}}]);