"use strict";(self.webpackChunkdocs_component_markup=self.webpackChunkdocs_component_markup||[]).push([[391],{2410:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"tag_syntax","title":"Tag Syntax","description":"This markup-language has been heavily inspired by XML while also making various domain-specific improvements as to reduce friction when trying to depict component-templates. The following overview will outline its features and facets one by one, all while explaining why these patterns are in place.","source":"@site/docs/tag_syntax.mdx","sourceDirName":".","slug":"/tag_syntax","permalink":"/docs-component-markup/docs/tag_syntax","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs-component-markup/docs/intro"},"next":{"title":"Expression Syntax","permalink":"/docs-component-markup/docs/expression_syntax"}}');var i=a(4848),s=a(8453),r=a(6025);const o={sidebar_position:2},l="Tag Syntax",c={},d=[{value:"Special Characters",id:"special-characters",level:2},{value:"Opening Pointy-Brackets",id:"opening-pointy-brackets",level:3},{value:"Curly-Brackets",id:"curly-brackets",level:3},{value:"Newlines And Whitespace",id:"newlines-and-whitespace",level:3},{value:"Placeholders",id:"placeholders",level:2},{value:"Tags",id:"tags",level:2},{value:"Opening And Closing",id:"opening-and-closing",level:3},{value:"Self-Closing",id:"self-closing",level:3},{value:"Let-Bindings",id:"let-bindings",level:3},{value:"Immediate Attribute-Values",id:"immediate-attribute-values",level:3},{value:"Dynamic Attribute-Values",id:"dynamic-attribute-values",level:3},{value:"If-Conditionals",id:"if-conditionals",level:3},{value:"When Matching",id:"when-matching",level:3},{value:"Use-Conditional",id:"use-conditional",level:3},{value:"Generative Loops",id:"generative-loops",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"tag-syntax",children:"Tag Syntax"})}),"\n",(0,i.jsx)(n.p,{children:"This markup-language has been heavily inspired by XML while also making various domain-specific improvements as to reduce friction when trying to depict component-templates. The following overview will outline its features and facets one by one, all while explaining why these patterns are in place."}),"\n",(0,i.jsx)(n.h2,{id:"special-characters",children:"Special Characters"}),"\n",(0,i.jsx)(n.p,{children:"All text other than tags themselves which is also outside of placeholder-notation is not constrained in any way, besides the very few exceptions discussed below; keeping syntactic noise to a bare minimum is a conscious design-decision."}),"\n",(0,i.jsx)(n.h3,{id:"opening-pointy-brackets",children:"Opening Pointy-Brackets"}),"\n",(0,i.jsxs)(n.p,{children:["Literal opening pointy-brackets are ",(0,i.jsx)(n.strong,{children:"always"})," to be marked by a leading backslash in order to avoid them erroneously being interpreted as the beginning of a tag. The input"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"This text does not open a \\<new tag! :)\n"})}),"\n",(0,i.jsx)(n.p,{children:"becomes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-txt",children:"This text does not open a <new tag! :)\n"})}),"\n",(0,i.jsx)(n.p,{children:"once processed."}),"\n",(0,i.jsx)(n.h3,{id:"curly-brackets",children:"Curly-Brackets"}),"\n",(0,i.jsxs)(n.p,{children:["Literal curly-brackets are ",(0,i.jsx)(n.strong,{children:"always"})," to be marked by a leading backslash in order to avoid them erroneously being interpreted as the premature end of a tag-attribute's markup-value or the beginning of a placeholder:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<my-tag\n  my-attribute={\n    <red>This curly bracket \\} does not close the attribute's input!\n  }\n/>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The value of ",(0,i.jsx)(n.code,{children:"my-attribute"})," will become"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red>This curly bracket } does not close the attribute's input!\n"})}),"\n",(0,i.jsx)(n.p,{children:"once processed. Also"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"This \\{ curly-bracket does not mark a placeholder!\n"})}),"\n",(0,i.jsx)(n.p,{children:"will become"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"This { curly-bracket does not mark a placeholder!\n"})}),"\n",(0,i.jsx)(n.p,{children:"once processed. It's best to, in general, think of curly-brackets as special and reserved tokens\nwithin this templating-language, because that's what they are; if to be used literally, do so with care."}),"\n",(0,i.jsx)(n.h3,{id:"newlines-and-whitespace",children:"Newlines And Whitespace"}),"\n",(0,i.jsxs)(n.p,{children:["All newlines and surrounding spaces, which includes indentation as well as trailing whitespace, will\nbe removed and thus do not end up in the rendered result; this fact allows the user to format their markup\nin any way that is visually appealing to work with. In order to inject ",(0,i.jsx)(n.a,{href:"/docs-component-markup/docs/built_in/linebreak",children:"Linebreaks"}),"\nor surrounding ",(0,i.jsx)(n.a,{href:"/docs-component-markup/docs/built_in/space",children:"Spaces"}),", please check out the corresponding tags as linked to learn\nmore about the details."]}),"\n",(0,i.jsx)(n.h2,{id:"placeholders",children:"Placeholders"}),"\n",(0,i.jsxs)(n.p,{children:["In order to substitute variables and various expressions in general into designated slots, said expressions are simply to be wrapped by a pair of matching curly-brackets. Let's assume that the variable ",(0,i.jsx)(n.code,{children:"l-me: player"})," holds a string-value of ",(0,i.jsx)(n.code,{children:"l-me: 'Steve'"}),", then the markup"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red>Hello, {player}!\n"})}),"\n",(0,i.jsx)(n.p,{children:"becomes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red>Hello, Steve!\n"})}),"\n",(0,i.jsx)(n.p,{children:"once processed. Placeholders must not span across multiple lines as to enforce readability and simplicity; expressions will always remain terse if employed as intended, in conjunction with structural attributes and bindings."}),"\n",(0,i.jsxs)(n.p,{children:["Whenever the result of an expression, no matter its complexity, is an instance of a ",(0,i.jsx)(n.code,{children:"MarkupNode"}),", said\nmarkup is immediately interpreted and thereby injected into its designated placeholder."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'MarkupNode outerMarkup = MarkupParser.parse(\n  // v- User-changeable value\n  "...",\n  BuiltInTagRegistry.INSTANCE\n);\n\nMarkupNode innerMarkup = MarkupParser.parse(\n  // v- This value could be another config-key\n  "<red><b>Hello, world!",\n  BuiltInTagRegistry.INSTANCE\n);\n\nComponentOutput components = MarkupInterpreter.interpret(\n  // v- Platform-specific\n  componentConstructor,\n  new InterpretationEnvironment()\n    .withVariable("inner_markup", innerMarkup),\n  // v- No immediate recipient-personalization required\n  null,\n  SlotType.CHAT,\n  outerMarkup\n);\n\n// v- Platform-specific\ncomponentApplicator.sendInChat(player, components);\n'})}),"\n",(0,i.jsx)(n.p,{children:"With a user-changable value of"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<aqua>Before</>\n<br/>\n<container *for="1..3" for-separator={<br/>}>{inner_markup}</>\n<br/>\n<gold>After</>\n'})}),"\n",(0,i.jsx)(n.p,{children:"the final result thus becomes"}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/markup_interpolation_example.png")}),"\n",(0,i.jsx)(n.p,{children:"As becomes immediately apparent, this powerful feature allows to define reusable templates which then\nmay be injected and augmented (conditions, loops, etc.) as needed; when evaluating said templates, they\nare granted access to all environment-variables and bindings which are available at their placeholder's position.\nDue to the fact that only pre-parsed nodes are renderable via this method, there's no additional computational\nburden caused by reusable partial templates in comparison to defining the whole template all in one place."}),"\n",(0,i.jsx)(n.h2,{id:"tags",children:"Tags"}),"\n",(0,i.jsxs)(n.p,{children:["Tags represent calls to internally existing functionality, which then can modify and or generate content dynamically; see ",(0,i.jsx)(n.a,{href:"./category/built-in-tags",children:"Built-In Tags"})," to discover predefined features and check out the ",(0,i.jsx)(n.a,{href:"/docs-component-markup/docs/extension_api",children:"Extension API"})," as to learn about creating your own. There are two types of notation: one being comprised of an opening- and a (optional) closing-tag, while the other self-closes within the opening-tag and thereby does not bear any content."]}),"\n",(0,i.jsx)(n.h3,{id:"opening-and-closing",children:"Opening And Closing"}),"\n",(0,i.jsxs)(n.p,{children:["When invoking a tag which holds content, the tag becomes enabled to modify said members in order to implement various visual and/or generative transformations. The opening-tag is simply surrounded by pointy-brackets ",(0,i.jsx)(n.code,{children:"l-cm: <name>"}),", while the closing-tag has to be equally named, with the addition of a slash right before said name ",(0,i.jsx)(n.code,{children:"l-cm: </name>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red>\n  <bold>Some bold text</bold>\n  <italic>Some italic text\n</red>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, both the ",(0,i.jsx)(n.code,{children:"bold"})," and ",(0,i.jsx)(n.code,{children:"italic"})," passages will be colored ",(0,i.jsx)(n.code,{children:"red"}),", as they are members of the corresponding invocation to colorise; as can be seen also, the ",(0,i.jsx)(n.code,{children:"italic"}),"-tag's closing has been omitted, which will be carried out implicitly once its parent closes, or the very end of the code has been reached. For simple scenarios, implicit closing can help with brevity, but for complex templates, it is not advised to rely on this feature, as unexpected implications may follow which add needless mental overhead regarding their reader and maintainer."]}),"\n",(0,i.jsxs)(n.p,{children:["As a compromise between brevity and exactness, a shorthand-tag has been introduced, namely ",(0,i.jsx)(n.code,{children:"l-cm: </>"}),", which simply closes the last opened tag but does so without having to specify its name all over again. It is avised to employ this shorthand as much as possible within smaller areas of the template in order to avoid unexpected behaviour with auto-close, while as soon as an indented nesting-depth of three is exceeded, named closing-tags should instead be applied to parents, in order to visually aid the user in understanding the layout they're faced with."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red>\n  <bold>Some bold text</>\n  <italic>Some italic text</>\n</>\n"})}),"\n",(0,i.jsxs)(n.p,{children:['If a "hard-reset" is to be achieved, there also exists the close-all tag, namely ',(0,i.jsx)(n.code,{children:"l-cm: </*>"}),", which will close every\ntag that is currently open and thus bring whatever follows after it right back to root-level scope. Again, it is\nstrongly advised to handle this special feature with great care."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red><b><i>I am formatted!</*>I am plain!\n"})}),"\n",(0,i.jsx)(n.h3,{id:"self-closing",children:"Self-Closing"}),"\n",(0,i.jsxs)(n.p,{children:["Tags which bear no content, as they simply insert data retrieved externally or mark special instructions, self-close by adding a slash right before the closing pointy-bracket ",(0,i.jsx)(n.code,{children:"l-cm: <name/>"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"The tag <my-tag/> self-closes and thus needs no corresponding closing-tag!\n"})}),"\n",(0,i.jsx)(n.h3,{id:"let-bindings",children:"Let-Bindings"}),"\n",(0,i.jsxs)(n.p,{children:["Each tag, no matter its underlying implementation, supports binding the result of expressions to temporary variables whose lifetime spans the content of said tag. While there are many uses for this feature, one of the simplest will be to extract complex common expressions. In order to introduce such a binding, make use of the reserved ",(0,i.jsx)(n.code,{children:"let-"})," attribute namespace, where the identifier after the dash denotes the name of the newly introduced temporary variable."]}),"\n",(0,i.jsx)(n.p,{children:"When providing immediate values which are not of type string, i.e. numbers and booleans, variables are directly bound to the specified constant, not requiring them to be wrapped by expressions artificially. Bindings are evaluated in top-down order, meaning that later bindings can access the results of their predecessors, allowing for dependent expressions, as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container\n  let-a=5\n  let-b=12\n  let-c="b - a"\n  let-d=3\n  let-e="c ^ d"\n>{e}"\n'})}),"\n",(0,i.jsxs)(n.p,{children:["which will display a value of ",(0,i.jsx)(n.code,{children:"343"}),". Attribute-values of type string are ",(0,i.jsx)(n.strong,{children:"always"})," interpreted as an expression (square brackets must ",(0,i.jsx)(n.strong,{children:"not"})," be added explicitly!)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<red let-my_var="my.complex.extracted.expression">\n  <bold>First use {my_var} of it</>\n  <italic>Second use {my_var} of it</>\n</>\n'})}),"\n",(0,i.jsx)(n.p,{children:"Next to expressions, markup-values may also be bound to temporary variables, effectively allowing to define reusable components."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<container\n  let-spacer={\n    <dark_gray><st>{ ' ' ** 15 }\n  }\n>\n  {spacer}<br/>\n  <aqua>First line!</><br/>\n  {spacer}<br/>\n  <aqua>Second line!</><br/>\n  {spacer}<br/>\n  <aqua>Third line!</><br/>\n  {spacer}\n</>\n"})}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/let_binding_markup.png")}),"\n",(0,i.jsxs)(n.p,{children:["Please note that variables, by enforced convention, always follow the ",(0,i.jsx)(n.code,{children:"snake_case"}),"-style, meaning being all lower-case with spaces represented as underscores. In contrast, tag- as well as attribute-names enforce the same pattern, just with the alteration of them swapping out underscores for hyphens, making it become ",(0,i.jsx)(n.code,{children:"kebab-case"}),". By this simple yet effective differentiation, it is immediately visually obvious to which realm an identifier belongs to."]}),"\n",(0,i.jsx)(n.h3,{id:"immediate-attribute-values",children:"Immediate Attribute-Values"}),"\n",(0,i.jsx)(n.p,{children:"All opening-tags, including the self-closing kind, may support a variety of attributes - be they simple scalar values or more complex markup."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<my-tag\n  a="my value"\n  b=5\n  c=3.42\n  d=true\n  e=false\n  f\n  g={\n    <red>Hello, world!\n  }\n/>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, ",(0,i.jsx)(n.code,{children:"a"})," is of type string (sequence of characters), ",(0,i.jsx)(n.code,{children:"b"})," of type whole number, ",(0,i.jsx)(n.code,{children:"c"})," of type floating-point number, ",(0,i.jsx)(n.code,{children:"d"})," and ",(0,i.jsx)(n.code,{children:"e"})," of type boolean, ",(0,i.jsx)(n.code,{children:"f"})," also of type boolean (flag-style ",(0,i.jsx)(n.code,{children:"l-me: true"}),"-value) and ",(0,i.jsx)(n.code,{children:"g"})," being a markup-value, delimited by curly-brackets. In general, the only differentiation occurs between markup-values and scalar-values (string, number, boolean), where the latter will never cause a type-mismatch and simply be interpreted as required."]}),"\n",(0,i.jsx)(n.p,{children:"Attributes which support multiple values may be assigned more than once - each occurrence will be collected and passed to the tag as a list when executing it, maintaining the top-down order of assignment."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<translate\n  key="chat.type.advancement.challenge"\n  with={<green>Username}\n  with={<green>Challenge-Name}\n/>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the two values of ",(0,i.jsx)(n.code,{children:"with"})," will be matched with the two placeholders of the ",(0,i.jsx)(n.code,{children:"challenge"})," translation-message by the client; such messages may have a different number of slots, with component-markup allowing the user to specify as many values as necessary."]}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-attribute-values",children:"Dynamic Attribute-Values"}),"\n",(0,i.jsxs)(n.p,{children:["Attributes also support dynamic values, meaning values which are not specified immediately but rather are to be retrieved by evaluating an expression; to indicate this behaviour, simply enclose the attribute-name by a pair of square-brackets ",(0,i.jsx)(n.code,{children:"[]"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<my-tag\n  [my-attribute]="user.name"\n/>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now, ",(0,i.jsx)(n.code,{children:"my-attribute"})," will be assigned to whatever value the expression ",(0,i.jsx)(n.code,{children:"l-me: user.name"})," evaluates to."]}),"\n",(0,i.jsxs)(n.p,{children:["Whenever attributes support multiple values ",(0,i.jsx)(n.strong,{children:"and"})," are enclosed by square-brackets ",(0,i.jsx)(n.code,{children:"[]"})," in order to be bound to an expression, the spread-operator ",(0,i.jsx)(n.code,{children:"..."})," may be prepended to the attribute-name within said brackets in order to evaluate the result of the expression and instantiate an attribute-value for each item of the list it returns (becomes a singleton-list if the expression returns a scalar)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<my-tag [...my-attribute]=\"['hello', 'world', 'test']\">\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, the attribute ",(0,i.jsx)(n.code,{children:"my-attribute"})," of the tag ",(0,i.jsx)(n.code,{children:"my-tag"})," will be instantiated once for each item of the ",(0,i.jsx)(n.a,{href:"/docs-component-markup/docs/expression_syntax#immediate-list",children:"Immediate List"})," ",(0,i.jsx)(n.code,{children:"l-me: ['hello', 'world', 'test']"}),", such that the resulting meaning effectively becomes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<my-tag\n  [my-attribute]=\"'hello'\"\n  [my-attribute]=\"'world'\"\n  [my-attribute]=\"'test'\"\n>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This can be very useful for data-driven rendering, where the environment holds lists of values which are to be ",(0,i.jsx)(n.strong,{children:"individually"})," bound to tag-attributes. Beware of the fact that if the spreading-operator is not employed on a multi-value attribute, results may vastly differ from expectations, because a ",(0,i.jsx)(n.strong,{children:"single attribute-value"})," holding the outermost list is not equivalent to ",(0,i.jsx)(n.strong,{children:"multiple attribute-values"})," each holding a single item of said list."]}),"\n",(0,i.jsxs)(n.p,{children:["The features as described above also apply to attributes which require their values to be of type markup (",(0,i.jsx)(n.code,{children:"={...}"}),"), with the following rules of operation:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Scalar non-markup values are interpreted as plain text"}),"\n",(0,i.jsx)(n.li,{children:"Scalar markup values are interpreted as-is (rich components)"}),"\n",(0,i.jsxs)(n.li,{children:["Lists are:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Interpreted item by item if not using the spread-operator ",(0,i.jsx)(n.code,{children:"..."})]}),"\n",(0,i.jsxs)(n.li,{children:["Instantiating one attribute-value per item if using the spread-operator ",(0,i.jsx)(n.code,{children:"..."})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The result of the input"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<translate\n  key="chat.type.advancement.challenge"\n  with={<aqua>Username}\n  with={<aqua>Challenge-Name}\n/>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["is equivalent to that of (using ",(0,i.jsx)(n.a,{href:"#let-bindings",children:"Let-Bindings"})," to introduce markup-variables; they could just as well come from the environment)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container\n  let-first={<aqua>Username}\n  let-second={<aqua>Challenge-Name}\n>\n  <translate\n    key="chat.type.advancement.challenge"\n    [...with]="[first, second]"\n  />\n'})}),"\n",(0,i.jsxs)(n.p,{children:["since it assigns one list-item to one instance of the ",(0,i.jsx)(n.code,{children:"with"}),"-attribute, due to the spread-operator being present, yielding:"]}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/markup_attribute_binding_spread.png")}),"\n",(0,i.jsxs)(n.p,{children:["In contrast to the above, if not using the spread-operator, components will simply be interpreted sequentially, with the result becoming the value of ",(0,i.jsx)(n.strong,{children:"a single"})," attribute-instance; the following example portrays said behaviour (the ",(0,i.jsx)(n.code,{children:"Third"})," value was manually added because ",(0,i.jsx)(n.code,{children:"translate"}),"-components do not render if the count of their placeholders is not matched - that's a client-side limitation):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container\n  let-first={<aqua>First}\n  let-second={<aqua>Second}\n>\n  <translate\n    key="chat.type.advancement.challenge"\n    [with]="[first, second]"\n    with={<red>Third}\n  />\n'})}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/markup_attribute_binding_non_spread.png")}),"\n",(0,i.jsx)(n.p,{children:"As mentioned earlier, non-markup values will simply be interpreted as plain text:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container\n  let-first="\'hello, world\'"\n>\n  <translate\n    key="chat.type.advancement.challenge"\n    [with]="first"\n    with={<red>Second}\n  />\n'})}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/markup_attribute_binding_non_markup.png")}),"\n",(0,i.jsx)(n.h3,{id:"if-conditionals",children:"If-Conditionals"}),"\n",(0,i.jsxs)(n.p,{children:["The simplest form of a conditional is represented by the intrinsic ",(0,i.jsx)(n.code,{children:"*if"})," structural attribute, which is ",(0,i.jsx)(n.strong,{children:"always"})," treated as an expression (square brackets must ",(0,i.jsx)(n.strong,{children:"not"})," be added explicitly); if matching, the tag to which it is applied shows up and if not, the tag will not be evaluated."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<red *if="my_condition">Shown if the condition matches!</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Once a conditional has been declared as can be seen above, the structural attributes ",(0,i.jsx)(n.code,{children:"*else-if"})," as well as ",(0,i.jsx)(n.code,{children:"*else"})," are now available to its direct siblings, meaning elements which succeed it on the same level of nesting."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<red *if="my_number == 1">Shown if the value is one!</>\n<red *else-if="my_number == 2">Shown if the value is two!</>\n<red *else-if="my_number == 3">Shown if the value is three!</>\n<red *else>Shown if the value is anything else!</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"*else-if"}),"-branches are evaluated in the order they are specified in and only once the main ",(0,i.jsx)(n.code,{children:"*if"}),"-condition failed; once an ",(0,i.jsx)(n.code,{children:"*else-if"}),"-conditional matched, all others, including the ",(0,i.jsx)(n.code,{children:"*else"}),"-fallthrough will not evaluate; if all conditions fail, the ",(0,i.jsx)(n.code,{children:"*else"}),"-case will show up in the result (note that it has no value assigned and also does not accept one, for logical reasons)."]}),"\n",(0,i.jsxs)(n.p,{children:["These ",(0,i.jsx)(n.code,{children:"*if"}),"-/",(0,i.jsx)(n.code,{children:"*else-if"}),"-/",(0,i.jsx)(n.code,{children:"*else"}),"-sequences need to be organised as a single block of subsequent members, meaning that there cannot be any intermediate nodes not being part of the case-decision; if that is desired, simply use standalone ",(0,i.jsx)(n.code,{children:"*if"}),"-clauses."]}),"\n",(0,i.jsxs)(n.p,{children:["Multiple such sequences may coexist one after another on the same level of depth, separated by their initial ",(0,i.jsx)(n.code,{children:"*if"}),"-conditional; they may also be nested to any arbitrary complexity. This way, nuanced decisions may be depicted with minimal syntactic effort."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'\x3c!-- First independent block --\x3e\n<red *if="condition_1">Shown when condition 1 is met!</>\n<red *else>Shown if condition 1 is not met!</>\n\n\x3c!-- Second independent block --\x3e\n<red *if="condition_2">\n  \x3c!-- Nested conditionals --\x3e\n  <bold *if="condition_3">Shown when both condition 2 and 3 are met!</>\n  <italic *else>Shown when only condition 2 is met!</>\n</>\n<red *else>Shown if condition 2 is not met!</>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"when-matching",children:"When Matching"}),"\n",(0,i.jsxs)(n.p,{children:["In contrast to ",(0,i.jsx)(n.code,{children:"*if"}),"-conditionals, where expressions are evaluated to ",(0,i.jsx)(n.code,{children:"l-me: true"})," and ",(0,i.jsx)(n.code,{children:"l-me: false"})," in order\nto decide which branch to evaluate, processed in a top-down order, ",(0,i.jsx)(n.code,{children:"*when"}),"-matching is taking the value of an\nexpression as an input and then tries to match it against one of the existing cases; cases cannot be expressions\nbut are rather constrained to static string-values, such that internally, a hashing-algorithm can be applied\nin order to improve runtime performance - especially in comparison to the ",(0,i.jsx)(n.code,{children:"*if"}),"-equivalent. When-comparisons are always\ncase-insensitive; ",(0,i.jsx)(n.code,{children:"l-me: null"}),"-values always invoke the ",(0,i.jsx)(n.code,{children:"*other"}),"-fallback!"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container *when="my.input.expression">\n  <red *is="A">First case</>\n  <green *is="B">Second case</>\n  <blue *is="C">Third case</>\n  <gray *other>Fallback case</>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["If no specified ",(0,i.jsx)(n.code,{children:"*is"}),"-case applies, an optional ",(0,i.jsx)(n.code,{children:"*other"}),"-fallback may be provided to evaluate; if absent, nothing\nwill be rendered. The above is functionally (but not computationally!) equivalent to the following ",(0,i.jsx)(n.code,{children:"*if"}),"-chain,\nwhich is ",(0,i.jsx)(n.em,{children:"absolutely advised against"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<red *if=\"my.input.expression == 'A'\">First case</>\n<green *else-if=\"my.input.expression == 'B'\">Second case</>\n<blue *else-if=\"my.input.expression == 'C'\">Third case</>\n<gray *else>Fallback case</>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As always, these structural attributes may be applied to any tag, which means that if the cases are already wrapped\nin a parent-container due to the template at hand, one does not need to introduce an extra ",(0,i.jsx)(n.code,{children:"container"})," - it simply\nserves as an invisible wrapper for ",(0,i.jsx)(n.code,{children:"*is"}),"-cases. ",(0,i.jsx)(n.strong,{children:"All"})," children within the parent holding the ",(0,i.jsx)(n.code,{children:"*when"}),"-attribute\nare required to be members of the matching-process, meaning ",(0,i.jsx)(n.code,{children:"*is"}),"-cases or an ",(0,i.jsx)(n.code,{children:"*other"}),", where the latter may only\nexist once; consider this whole block as atomic - it cannot be split up, cannot be injected with static content and\nalways evaluates to a single branch within it."]}),"\n",(0,i.jsx)(n.p,{children:"In case it is ever truly needed, when-matching can be nested, as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container *when="first_input">\n  <red *is="A">Case A</>\n  <green *is="B">Case B</>\n  <container *is="C" *when="second_input">\n    <gold *is="D">Case D within C</>\n    <yellow *is="E">Case E within C</>\n  </>\n  <gray *other>Fallback Case</>\n</>\n'})}),"\n",(0,i.jsx)(n.h3,{id:"use-conditional",children:"Use-Conditional"}),"\n",(0,i.jsxs)(n.p,{children:["If instead of disabling the applied-to element and its children altogether, the intrinsic ",(0,i.jsx)(n.code,{children:"*use"})," structural attribute\nallows to only prevent the very tag it is applied to from taking effect, while still always rendering its content; that\nsaid, the ",(0,i.jsx)(n.code,{children:"*if"})," condition takes precedence and when it itself evaluates to ",(0,i.jsx)(n.code,{children:"l-me: false"}),", the ",(0,i.jsx)(n.code,{children:"*use"})," condition will\nnot have any effect."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<rainbow *if="show_text" *use="enable_rainbow">Hello, world!</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, if ",(0,i.jsx)(n.code,{children:"l-me: show_text"})," evaluates to ",(0,i.jsx)(n.code,{children:"l-me: false"}),", the entire tag will not render, including its\ntextual contents; otherwise, the value of ",(0,i.jsx)(n.code,{children:"l-me: enable_rainbow"})," dictates whether the rainbow is applied or not - if it\nevaluates to ",(0,i.jsx)(n.code,{children:"l-me: false"}),", the text ",(0,i.jsx)(n.code,{children:"Hello, world!"})," will remain uncolorized."]}),"\n",(0,i.jsx)(n.h3,{id:"generative-loops",children:"Generative Loops"}),"\n",(0,i.jsxs)(n.p,{children:["In order to generate content based on a sequence of data-points, the intrinsic ",(0,i.jsx)(n.code,{children:"*for"})," structural attribute may be employed; it is a mere attribute that can be added to any existing tag, instantiating it once for each point of data. In order to assign the current item to an accessible variable, specify its name right after a hyphen attached to the structural attribute, akin to ",(0,i.jsx)(n.a,{href:"#let-bindings",children:"Let-Bindings"}),". The value is ",(0,i.jsx)(n.strong,{children:"always"})," interpreted as an expression (square brackets must ",(0,i.jsx)(n.strong,{children:"not"})," be added explicitly)."]}),"\n",(0,i.jsx)(n.p,{children:"Once employed, the additional attributes become available:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"for-separator"}),", accepting an optional markup-value to be injected inbetween iterations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"for-reversed"}),", accepting an optional boolean marking whether to iterate in reverse order"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["When there's no need to access the current item of iteration, simply drop the dash and use the attribute as-is; this shorter style is especially useful in combination with ",(0,i.jsx)(n.a,{href:"/docs-component-markup/docs/expression_syntax#range-operator",children:"Ranges"})," (the ",(0,i.jsx)(n.code,{children:"l-me: loop"})," context is discussed further below)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<red *for="1..10">The #{loop.index + 1} occurrence of this line!\n'})}),"\n",(0,i.jsx)(n.p,{children:"When iteration-items are required, simply attach the desired variable-name with a hyphen to the attribute."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<gray>\n  Online players:<space/>\n  <red\n    *for-player_name="player_names"\n    for-separator={<gray>, }\n  >{player_name}</>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The example above will generate the ",(0,i.jsx)(n.code,{children:"red"})," tag once for each name in the list, injecting the ",(0,i.jsx)(n.code,{children:"gray"})," separators inbetween iterations. If items are to be skipped based on a ",(0,i.jsx)(n.a,{href:"#if-conditionals",children:"Condition"}),", simply also add in the corresponding ",(0,i.jsx)(n.code,{children:"*if"})," structural attribute."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's skip names equal to ",(0,i.jsx)(n.code,{children:"Steve"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<gray>\n  Online players:<space/>\n  <red\n    *for-player_name="player_names"\n    *if="player_name != \'Steve\'"\n    for-separator={<gray>, }\n  >{player_name}</>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this context, meaning when combined with a loop, the ",(0,i.jsx)(n.code,{children:"*if"}),"-condition may not be chained with ",(0,i.jsx)(n.code,{children:"*else-if"}),"/",(0,i.jsx)(n.code,{children:"*else"})," structural attributes, as it does not control whether the ",(0,i.jsx)(n.em,{children:"node"})," is rendered, but whether an ",(0,i.jsx)(n.em,{children:"iteration"})," is rendered, and thereby becomes attached with a completely different meaning. For more nuanced control, consider adding conditions on child-tags."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's render an alternate name for ",(0,i.jsx)(n.code,{children:"Steve"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<gray>\n  Online players:<space/>\n  <container\n    *for-player_name="player_names"\n    for-separator={<gray>, }\n  >\n    <green *if="player_name == \'Steve\'">Alternate Name Here</>\n    <red *else>{player_name}</>\n  </>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Additional information is made available via the implicitly added temporary variable called ",(0,i.jsx)(n.code,{children:"l-me: loop"}),"; it also only exists for the duration of the tag-contents to which the ",(0,i.jsx)(n.code,{children:"*for"})," structural attribute has been applied to. It itself holds the following useful properties, updated for each iteration:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: index"}),": Zero-based sequence-number of the current element"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: length"}),": Number of elements to be iterated over in total"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: is_even"}),": Whether the ",(0,i.jsx)(n.code,{children:"l-me: index"})," is an even number"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: is_odd"}),": Whether the ",(0,i.jsx)(n.code,{children:"l-me: index"})," is an odd number"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: is_first"}),": Whether the item is the first of the sequence"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"l-me: is_last"}),": Whether the item is the last of the sequence"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["For single loops, accessing this variable directly marks the most straight-forward way; let's add positions (",(0,i.jsx)(n.code,{children:"#1"}),", ",(0,i.jsx)(n.code,{children:"#2"}),", ...) to the prior example."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<gray>\n  Online players:<space/>\n  <red\n    *for-player_name="player_names"\n    *if="player_name != \'Steve\'"\n    for-separator={<gray>, }\n  >#{loop.index + 1} {player_name}</>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["To generate multiple elements per iteration, make use of the invisible ",(0,i.jsx)(n.code,{children:"container"}),"-tag:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:'<container\n  *for-player_name="player_names"\n  for-separator={<br/>}\n>\n  <red>First member</>\n  <green>Second member</>\n  <blue>Third member</>\n  <gold>Greetings, {player_name}!</>\n</>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Whenever attribute-values are of type markup, as is the case with the ",(0,i.jsx)(n.code,{children:"for-separator"}),", nesting may\nextend to any arbitrary depth; e.g. a separator which again displays ",(0,i.jsx)(n.code,{children:"hover-text"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-component-markup",children:"<container\n  *for-word=\"['first', 'second', 'third']\"\n  for-separator={\n    <hover-text value={<red>I am a separator!}>,<space/>\n  }\n>\n  <hover-text value={<red>I am an element!}>\n    <gray>#{loop.index + 1} <red>{word}\n"})}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/nested_markup_element.png")}),"\n",(0,i.jsx)("img",{className:"rendered-image",src:(0,r.Ay)("/img/nested_markup_separator.png")})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var t=a(6540);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);