"use strict";(globalThis.webpackChunkdocs_component_markup=globalThis.webpackChunkdocs_component_markup||[]).push([[255],{3106:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"types","title":"Types","description":"In general, tags only statically differentiate between two types: expression and markup. If an expression is assigned to a markup-attribute or vice-versa, parsing will fail as to protect the user from errors during interpretation. All expression-values are interpreted however the tag at hand see fit, with proper fallbacks and console-logs, such that no functionality-inhibitative error may ever occur.","source":"@site/docs/types.mdx","sourceDirName":".","slug":"/types","permalink":"/docs-component-markup/docs/types","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Consumer API","permalink":"/docs-component-markup/docs/consumer_api"},"next":{"title":"Built-In Tags","permalink":"/docs-component-markup/docs/category/built-in-tags"}}');var r=a(4848),t=a(8453),l=a(3558),i=a(7420);const o={sidebar_position:8},c="Types",d={},p=[{value:"Markup",id:"markup",level:2},{value:"String",id:"string",level:2},{value:"Color",id:"color",level:2},{value:"Ampersand Sequences",id:"ampersand-sequences",level:3},{value:"Ansi Colors",id:"ansi-colors",level:3},{value:"Hex Colors",id:"hex-colors",level:3},{value:"Boolean",id:"boolean",level:2},{value:"Number",id:"number",level:2},{value:"The ValueInterpreter",id:"the-valueinterpreter",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"types",children:"Types"})}),"\n",(0,r.jsx)(n.p,{children:"In general, tags only statically differentiate between two types: expression and markup. If an expression is assigned to a markup-attribute or vice-versa, parsing will fail as to protect the user from errors during interpretation. All expression-values are interpreted however the tag at hand see fit, with proper fallbacks and console-logs, such that no functionality-inhibitative error may ever occur."}),"\n",(0,r.jsx)(n.h2,{id:"markup",children:"Markup"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(l.H,{type:i.j.MARKUP})," type refers to the main language of this system, namely ",(0,r.jsx)(n.a,{href:"./tag_syntax",children:"Tag Syntax"})," - i.e. an arbitrarily complex construction of tags and attributes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<bold>\n  <red>This text is red!</><br/>\n  <aqua>This text is aqua!</><br/>\n  <blue>This text is blue!</><br/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"This exact, full and unrestricted markup may not just be either at the top level, or at the contents of another tag, but also be an attribute-value, as follows:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<hover-text\n  value={\n    <bold>\n      <red>This text is red!</><br/>\n      <aqua>This text is aqua!</><br/>\n      <blue>This text is blue!</><br/>\n  }\n><aqua>My text\n"})}),"\n",(0,r.jsx)(n.p,{children:"Which, of course, also includes let-bindings, as to create reusable components."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<container\n  *let-my_component={\n    <bold>\n      <red>This text is red!</><br/>\n      <aqua>This text is aqua!</><br/>\n      <blue>This text is blue!</><br/>\n  }\n>{my_component}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"string",children:"String"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(l.H,{type:i.j.STRING})," type simply represents a sequence of characters, which can either be a direct and static attribute-value"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:'<translate key="I am a static string!"/>\n'})}),"\n",(0,r.jsx)(n.p,{children:"or the result of an expression interpreted as a string, where expression-strings are equivalent to markup-strings"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<translate [key]=\"'I am a static string!'\"/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"allowing for dynamic construction of arbitrary complexity"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<translate key=`Prefix {my_variable} suffix`/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Whenever markup-numbers or booleans are specified, their values are stringified if the underlying attribute requires a string-value, such that"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<translate key=512/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["becomes ",(0,r.jsx)(n.code,{children:'l-me: "512"'})," and"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<translate key/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["becomes ",(0,r.jsx)(n.code,{children:'l-me: "true"'}),", while its counterpart"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<translate key=false/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["becomes ",(0,r.jsx)(n.code,{children:'l-me: "false"'}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"color",children:"Color"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(l.H,{type:i.j.COLOR})," type operates on the ",(0,r.jsx)(l.H,{type:i.j.STRING})," type by stringifying whatever value is provided, to then interpret that result as a color-value. There are multiple accepted color-formats, as follows."]}),"\n",(0,r.jsx)(n.h3,{id:"ampersand-sequences",children:"Ampersand Sequences"}),"\n",(0,r.jsxs)(n.p,{children:["So-called legacy colors, of format ",(0,r.jsx)(n.code,{children:"&"})," followed by ",(0,r.jsx)(n.code,{children:"a-f"})," or ",(0,r.jsx)(n.code,{children:"0-9"}),", can directly be provided as colors, just like they are supported as ",(0,r.jsx)(n.a,{href:"./built_in/style#color-shorthands",children:"Color-Shorthands"})," on tags."]}),"\n",(0,r.jsx)(n.h3,{id:"ansi-colors",children:"Ansi Colors"}),"\n",(0,r.jsxs)(n.p,{children:["Every ampersand-sequence corresponds to an Ansi-Color name, e.g. ",(0,r.jsx)(n.code,{children:"&b"})," being named ",(0,r.jsx)(n.code,{children:"aqua"}),"; these names may also be provided as a color, and are again documented at the shorthands-reference above."]}),"\n",(0,r.jsx)(n.h3,{id:"hex-colors",children:"Hex Colors"}),"\n",(0,r.jsxs)(n.p,{children:["Last but not least, the full range of colors is made available via what is known as a hexadecimal color sequence - namely a hashtag ",(0,r.jsx)(n.code,{children:"#"})," followed up by two hexadecimal (",(0,r.jsx)(n.code,{children:"0-9"})," and ",(0,r.jsx)(n.code,{children:"A-F"}),") digits for each red, green and blue component, making for a final scheme of ",(0,r.jsx)(n.code,{children:"#RRGGBB"}),". Whenever an alpha-channel, meaning translucency, is supported, two more digits representing said alpha-value may be appended, i.e. ",(0,r.jsx)(n.code,{children:"#RRGGBBAA"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"boolean",children:"Boolean"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(l.H,{type:i.j.BOOLEAN})," type may either be directly supplied via markup (flag-style) attribute-values, i.e."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<my-tag boolean-attribute />\n"})}),"\n",(0,r.jsx)(n.p,{children:"or"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<my-tag boolean-attribute=false />\n"})}),"\n",(0,r.jsx)(n.p,{children:"or expression-literals, i.e."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:'<my-tag [boolean-attribute]="true" />\n'})}),"\n",(0,r.jsx)(n.p,{children:"or"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:'<my-tag [boolean-attribute]="false" />\n'})}),"\n",(0,r.jsxs)(n.p,{children:["When providing a ",(0,r.jsx)(l.H,{type:i.j.STRING})," type, it becomes ",(0,r.jsx)(n.code,{children:"l-me: true"})," when equaling to ",(0,r.jsx)(n.code,{children:"l-me: 'true'"}),", ",(0,r.jsx)(n.code,{children:"l-me: false"})," when equaling to ",(0,r.jsx)(n.code,{children:"l-me: 'false'"})," and in all other cases, ",(0,r.jsx)(n.code,{children:"l-me: true"})," if non-empty. When providing a ",(0,r.jsx)(l.H,{type:i.j.NUMBER}),", ",(0,r.jsx)(n.code,{children:"l-me: true"})," is only achieved for values not equal to ",(0,r.jsx)(n.code,{children:"l-me: 0"}),". Also, ",(0,r.jsx)(n.code,{children:"l-me: null"}),"-values always result in ",(0,r.jsx)(n.code,{children:"l-me: false"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"number",children:"Number"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(l.H,{type:i.j.NUMBER})," type accepts either whole numbers (longs)"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<my-tag numeric-attribute=512/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"or fractional numbers (doubles)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-component-markup",children:"<my-tag numeric-attribute=3.141592/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"where if an attribute operates on whole numbers only, decimal digits will be truncated."}),"\n",(0,r.jsxs)(n.p,{children:["When providing a ",(0,r.jsx)(l.H,{type:i.j.BOOLEAN}),", ",(0,r.jsx)(n.code,{children:"l-me: true"})," yields ",(0,r.jsx)(n.code,{children:"l-me: 1"})," and ",(0,r.jsx)(n.code,{children:"l-me: false"})," yields ",(0,r.jsx)(n.code,{children:"l-me: 0"}),". When providing a ",(0,r.jsx)(l.H,{type:i.j.STRING}),", the system tries to parse it as a number, meaning that ",(0,r.jsx)(n.code,{children:"l-me: '512'"})," will become ",(0,r.jsx)(n.code,{children:"l-me: 512"}),"; malformed numbers result in ",(0,r.jsx)(n.code,{children:"l-me: 0"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"the-valueinterpreter",children:"The ValueInterpreter"}),"\n",(0,r.jsxs)(n.p,{children:["The behavior of interpreting one type as another is defined by the ",(0,r.jsx)(n.code,{children:"ValueInterpreter"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public interface ValueInterpreter {\n\n  long asLong(@Nullable Object value);\n\n  double asDouble(@Nullable Object value);\n\n  @NotNull Number asLongOrDouble(@Nullable Object value);\n\n  boolean asBoolean(@Nullable Object value);\n\n  @NotNull String asString(@Nullable Object value);\n\n  @NotNull List<Object> asList(@Nullable Object value);\n\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["There's a default implementation provided with every instance of the ",(0,r.jsx)(n.code,{children:"InterpretationEnvironment"}),", which can be overridden by a custom version using the environment's builder-functions; this is not recommended, since users should be able to predict interpretation as to reduce mental overhead - yet, this feature is kept for power-users."]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},3558:(e,n,a)=>{a.d(n,{H:()=>p,J:()=>u});a(6540);var s=a(3723),r=a(7420),t=a(3914),l=a(2503),i=a(6188),o=a(6025),c=a(2303),d=a(4848);const p=({type:e})=>(0,d.jsx)("a",{href:(0,o.Ay)(e.relativeDocsUrl),className:"unstyled-anchor",children:(0,d.jsx)("span",{style:{backgroundColor:e.color,color:"black",padding:"0 .1rem",borderRadius:".2rem",cursor:"pointer"},children:e.name})}),h=({tag:e,attribute:n})=>{const a=(0,s.decideClassName)("MARKUP__IDENTIFIER__ATTRIBUTE_USER"),r=(0,s.decideClassName)("EXPRESSION__PUNCTUATION__ANY");return(0,d.jsxs)("div",{children:[(0,d.jsx)(l.m_,{id:"attribute-tooltip"}),(0,d.jsxs)("p",{style:{margin:0,width:"max-content"},children:["\xa0\xa0",(0,d.jsxs)("span",{style:{marginRight:".4rem"},children:[(0,d.jsx)("span",{"data-tooltip-id":"attribute-tooltip","data-tooltip-content":null!==n.fallback?"Optional attribute":"Mandatory attribute",style:{color:null!==n.fallback?"#87E56B":"#FFA3A5"},children:(0,d.jsx)(t.g,{icon:null!==n.fallback?i.pNp:i.DW4})}),(0,d.jsx)("span",{"data-tooltip-id":"attribute-tooltip","data-tooltip-content":n.multiValue?"May be specified multiple times":"May only be specified once",style:{color:"#F8F856"},children:(0,d.jsx)(t.g,{size:"xs",icon:n.multiValue?i.ITF:i.ppD})})]}),(0,d.jsxs)("span",{"data-tooltip-id":"attribute-tooltip","data-tooltip-content":n.aliases.length>0?"Attribute-name and alias"+(n.aliases.length>1?"es":""):"Attribute-name",children:[(0,d.jsx)("span",{className:a,children:n.name}),n.aliases.map((e,n)=>(0,d.jsxs)("span",{className:a,children:[(0,d.jsx)("span",{className:r,children:","})," ",e]},n))]}),(0,d.jsxs)("span",{className:r,children:[":\xa0",(0,d.jsx)(p,{type:n.type}),null!==n.fallback&&(0,d.jsxs)("span",{style:{marginLeft:".5rem"},className:r,"data-tooltip-id":"attribute-tooltip","data-tooltip-content":"Default value",children:["(",(0,d.jsx)("span",{style:{color:n.type.color},children:n.fallback}),")"]})]})]}),(Array.isArray(n.description)?n.description:[n.description]).map((e,n)=>(0,d.jsxs)("p",{style:{margin:0,paddingLeft:".5rem",fontSize:".9rem",color:"gray",fontStyle:"italic",width:"max-content"},children:["\xa0\xa0\u21aa ",e]},n))]})},u=({tag:e})=>{(0,c.A)()&&(0,s.injectTokenStyle)();const n=(0,s.decideClassName)("MARKUP__PUNCTUATION__TAG"),a=(0,s.decideClassName)("MARKUP__IDENTIFIER__TAG"),t=(0,s.decideClassName)("EXPRESSION__PUNCTUATION__ANY");return(0,d.jsxs)("div",{style:{backgroundColor:"#1e1e1e",border:"var(--ifm-table-border-width) solid var(--ifm-table-border-color)",borderRadius:".4rem",fontFamily:'Menlo, Monaco, Consolas, "Andale Mono", "Ubuntu Mono", "Courier New", monospace',padding:".7rem 1rem",overflowX:"scroll",maxWidth:"max-content",margin:"1rem 0"},children:[(0,d.jsxs)("p",{style:{margin:0,width:"max-content"},children:[(0,d.jsx)("span",{className:n,children:"<"}),(0,d.jsx)("span",{className:a,children:e.name}),e.aliases.map((e,n)=>(0,d.jsxs)("span",{className:a,children:[(0,d.jsx)("span",{className:t,children:","})," ",e]},n))]}),e.attributes.map((n,a)=>(0,d.jsx)("div",{style:{marginTop:0==a?0:".5rem"},children:(0,d.jsx)(h,{tag:e,attribute:n})},a)),(0,d.jsx)("p",{style:{margin:0},children:e.selfClosing?(0,d.jsx)("span",{className:n,children:"/>"}):(0,d.jsxs)("span",{children:[(0,d.jsx)("span",{className:n,children:">"}),(0,d.jsx)("span",{style:{padding:"0 .5rem"},children:(0,d.jsx)(p,{type:r.j.MARKUP})}),(0,d.jsx)("span",{className:n,children:"</>"})]})})]})}},7420:(e,n,a)=>{a.d(n,{j:()=>s});class s{static MARKUP=new s("#D3A066","markup","/docs/types#markup");static STRING=new s("#BAD366","string","/docs/types#string");static COLOR=new s("#6be1cc","color","/docs/types#color");static BOOLEAN=new s("#9057CD","boolean","/docs/types#boolean");static NUMBER=new s("#CD6457","number","/docs/types#number");static COORDINATES=new s("#57cd71","coordinates","/docs/types#coordinates");static SELECTOR=new s("#cd57c1","selector","/docs/types#selector");constructor(e,n,a){this.color=e,this.name=n,this.relativeDocsUrl=a}}}}]);